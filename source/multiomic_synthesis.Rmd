---
title: "Workshop: generate GTF-style text files for protein ontology tracks"
author: "Angel Liang"
date: "16/04/2020"
output: html_document
---


# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
# font_import(paths = "~/.local/share/fonts/")
loadfonts(device = "pdf")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(ggpattern)
library(plotly)

library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
library(svglite)
library(scales)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multiprocess)
memory.limit(100000)
library(data.table)

# library(crayon)
# library(VennDiagram)

library(biomaRt)
httr::set_config(httr::config(ssl_verifypeer = FALSE))

ensembl_archive_name <- "sep2019"

ensembl_mart = useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = paste("http://", ensembl_archive_name, ".archive.ensembl.org", sep = ""))
# library(systemPipeR)
# library(GOstats)
# library(PFAM.db)
# library(bc3net)

# library(ComplexHeatmap)

library(ggdendro)
library(data.table)
# library(Rfast)

reference_data_dir <- "/mnt/LTS/reference_data/"

app_data_dir <- "/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite/data/"

results_dir <- "/mnt/LTS/projects/2020_isoform_nomenclature/results_multiomic_track_annotations/"

# ucsc_hg19_to_hg38_chainfile_path <- "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/hg19ToHg38.over.chain"

```

## define functions

### Enrichment/Gene Ontology

```{r}

# function to do Benjamini-Hochberg FDR correction for Gene Ontology output tables from GOHyperGall

## takes the output of the GOHyperGall GO enrichment table and over-writes the Padj column with benjamini-corrected values from the Phyper column
## spits out the resulting table with modified single column.

## NOTE: BENJAMINI PVALUES ABOVE 0.05 ARE RENAMED NA

GOHyperGAll_benjamini_correction <- function(raw_GOHyperGAll_table)

  {
  
  benjamini_GOHyperGAll_table <- raw_GOHyperGAll_table
  
  benjamini_GOHyperGAll_table <- benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$SampleMatch > 1, ]
  
  if (benjamini_GOHyperGAll_table %>% nrow == 0) {
    benjamini_GOHyperGAll_table <- tibble()
  } else {
    benjamini_GOHyperGAll_table[, "Padj"] <- p.adjust(p = benjamini_GOHyperGAll_table[, "Phyper"], method = "BH", n = length(benjamini_GOHyperGAll_table[, "Phyper"]))
    
    # benjamini_GOHyperGAll_table[benjamini_GOHyperGAll_table$Padj > 0.05, "Padj"] <- NA
  }

  return(benjamini_GOHyperGAll_table)
  
  }

# the equivalent for bc3net::enrichment() output table

bc3net_benjamini_correction <- function(raw_bc3net_table)

  {
  
  benjamini_bc3net_table <- raw_bc3net_table
  
  benjamini_bc3net_table_processed <- benjamini_bc3net_table[benjamini_bc3net_table$genes > 1, ]
  
  if (nrow(benjamini_bc3net_table_processed) != 0) {
  
  benjamini_bc3net_table_processed[, "padj"] <- p.adjust(p = benjamini_bc3net_table_processed[, "pval"], method = "BH", n = length(benjamini_bc3net_table_processed[, "pval"]))
  
  # benjamini_bc3net_table_processed[benjamini_bc3net_table_processed$padj > 0.05, "padj"] <- NA
  
  } else {
    
    benjamini_bc3net_table_processed <- benjamini_bc3net_table
    
    benjamini_bc3net_table_processed[, "padj"] <- NA
    
  }
  
  return(benjamini_bc3net_table_processed)
  
}

# bc3net::enrichment() does not show captured genes for each family enriched, so we have to add it in. but in doing so, i want to avoid a purrr within a purrr

# this function selects genes from the background in each family which are ONLY input genes.

filtering_genehits_from_background_catalogue <- function(catalogue, genehit_vector){
  
  filtered_catalogue <- purrr::map(.x = catalogue, .f = ~intersect(.x, genehit_vector))
  
  return(filtered_catalogue)
  
}

```

```{r}

# FUNCTION TO EXTRACT TRANSCRIPTS WITH JUNCTION-FLANKING EXONS.
# NOTE: to be used with purrr
# details of ONE junction: $chr, $start, $end, $strand
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_junction.flanking.exons <- function(query_chr, query_start, query_end, query_strand, tibble_gtf_table, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 1, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon") {
  
  # DEBUG ###
  # query_chr = b1$chr
  # query_start = b1$vector_alt_segment_starts
  # query_end = b1$vector_alt_segment_ends
  # query_strand = "*"
  # tibble_gtf_table = a2
  # tolerance_left = 0
  # tolerance_right = 0
  # tolerance_inside = 0
  # tolerance_outside = 0
  # match_consecutive = TRUE
  # return_type = ".*"
  ###########################
  
  # print(paste("now processing junction number", index))
  
  if (query_strand == "." | query_strand == 0 | query_strand == "*") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% .[.$start <= ((query_end %>% type.convert) + 1 + tolerance_outside + tolerance_left) & .$end >= ((query_start %>% type.convert) - 1 - tolerance_outside - tolerance_left), ] %>% .[!(.$start <= ((query_end %>% type.convert) - tolerance_inside - tolerance_right) & .$end >= ((query_start %>% type.convert) + tolerance_inside + tolerance_left)), ]
    
  } else if (query_strand == "+" | query_strand == "-") {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% .[.$strand == query_strand %>% trimws, ] %>% .[.$start <= ((query_end %>% type.convert) + 1 + tolerance_right) & .$end >= ((query_start %>% type.convert) - 1 - tolerance_left), ] %>% .[!(.$start <= ((query_end %>% type.convert) - tolerance_inside - tolerance_right) & .$end >= ((query_start %>% type.convert) + tolerance_inside + tolerance_left)), ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  if (tibble_gtf_subset_flanking_exons %>% nrow > 0) {
    
    tibble_gtf_subset_flanking_exons <- tibble_gtf_subset_flanking_exons %>% dplyr::filter(str_detect(string = `type`, pattern = return_type))
    
  }
  
  list_of_junction_associated_transcripts <- tibble_gtf_subset_flanking_exons$transcript_id %>% unique %>% array_tree %>% flatten
  
  # make a list for each transcript that directly flanks a junction.
  # then filter so that there are only a) exon PAIRS which b) are directly connected in the mature (spliced) transcript
  
  if (match_consecutive == TRUE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% type.convert)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2) %>% keep(.x = ., .p = ~abs((.x[2, "exon_number"] %>% paste %>% type.convert) - (.x[1, "exon_number"] %>% paste %>% type.convert)) == 1)
    
  } else if (match_consecutive == FALSE) {
    
    list_of_tibbles_flanking_exon_gtf.entries_per_transcript <- purrr::map(.x = list_of_junction_associated_transcripts, .f = ~tibble_gtf_subset_flanking_exons[tibble_gtf_subset_flanking_exons$transcript_id == .x, ] %>% dplyr::arrange(exon_number %>% type.convert)) %>% set_names(list_of_junction_associated_transcripts) %>% keep(.x = ., .p = ~nrow(.x) == 2)
    
  }
  
  return(list_of_tibbles_flanking_exon_gtf.entries_per_transcript)
  
}

# END extract_junction.flanking.exons_JUM() ###

```

```{r}

# FUNCTION TO EXTRACT REFERENCE EXONS WHICH OVERLAP EXACTLY WITH QUERY EXONS
# NOTE: to be used with purrr
# input: spliceregion_list: a list containing details of ONE junction: $chr, $vector_alt_segment_starts, $vector_alt_segment_ends
# tibble_gtf_table: rtracklayer::import(...) %>% as_tibble. can be any GTF. reconstructed or reference.
# index: loop progress marker to be used with imap

extract_matching.exons <- function(query_chr, query_start, query_end, query_strand, tibble_gtf_table, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon") {

  # DEBUG ###################
  # index <- 1
  # spliceregion_list <- wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR[[index]]
  # # tibble_gtf_table <- tibble_ref_gtf
  # tibble_gtf_table <- tibble_recon_gtf
  # stranded = FALSE
  ###########################

  # print(paste("now processing junction number", index))
  
  if (query_strand == "." | query_strand == 0 | query_strand == "*") {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% 
      .[which(.$start > ((query_start %>% as.numeric) - 1 - tolerance_left - tolerance_outside) & .$end < ((query_end %>% as.numeric) + 1 + tolerance_right + tolerance_outside)), ] %>% 
      .[which((.$start < ((query_start %>% as.numeric) + 1 + tolerance_left + tolerance_inside) & .$end > ((query_end %>% as.numeric) - 1 - tolerance_right - tolerance_inside))), ] %>% 
      .[which(.$type == return_type), ]
    
  } else if (query_strand == "+" | query_strand == "-") {
    
    # +/- 1 nt tolerance
    tibble_gtf_subset_overlapping_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws &
                                                              tibble_gtf_table$strand == query_strand %>% trimws, ] %>% 
      .[which(.$start > ((query_start %>% as.numeric) - 1 - tolerance_left - tolerance_outside) & .$end < ((query_end %>% as.numeric) + 1 + tolerance_right + tolerance_outside)), ] %>% 
      .[which((.$start < ((query_start %>% as.numeric) + 1 + tolerance_left + tolerance_inside) & .$end > ((query_end %>% as.numeric) - 1 - tolerance_right - tolerance_inside))), ] %>% 
      .[which(.$type == return_type), ]
    
  } else {
    
    stop("Could not match the strand information in the transposed differential-only UNION_junc_coor_table. Make sure that the \"strand\" column in the UNION_junc_coor_table contains only +, - or .")
    
  }
  
  return(tibble_gtf_subset_overlapping_exons)
  
}

```

```{r}

extract_overlapping_features <- function(query_chr, query_start, query_end, query_strand, tibble_gtf_table, left_query_shift = 0, right_query_shift = 0, left_tolerance = 0, right_tolerance = 0, return_type) {
    
    # DEBUG ###################
    # index <- 1
    # spliceregion_list <- wide_tibble_of_all_unique_VSR_and_exon_coords_array.tree_not_IR[[index]]
    # # tibble_gtf_table <- tibble_ref_gtf
    # tibble_gtf_table <- tibble_recon_gtf
    # stranded = FALSE
    ###########################
    
    # cat(query_chr, "\n")
    # cat(query_start, "\n")
    # cat(query_end, "\n")
    # cat(query_strand, "\n")
    # print(tibble_gtf_table, "\n")
    # cat(left_query_shift, "\n")
    # cat(right_query_shift, "\n")
    # cat(left_tolerance, "\n")
    # cat(right_tolerance, "\n")
    
    # print(paste("now processing junction number", index))
    
    # left_query_shift <<- left_query_shift
    # right_query_shift <<- right_query_shift
    # left_tolerance <<- left_tolerance
    # right_tolerance <<- right_tolerance
    
    if (!(query_strand == "+" | query_strand == "-")) {
        
        # +/- 1 nt tolerance
        tibble_gtf_subset_matching_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws, ] %>% 
            .[which(.$end >= ((query_start %>% as.numeric) + left_query_shift - left_tolerance) & .$start <= ((query_end %>% as.numeric) + right_query_shift + right_tolerance)), ] %>% 
            .[which(.$type == return_type), ]
        
    } else if (query_strand == "+" | query_strand == "-") {
        
        # +/- 1 nt tolerance
        tibble_gtf_subset_matching_exons <- tibble_gtf_table[tibble_gtf_table$seqnames == query_chr %>% trimws &
                                                                 tibble_gtf_table$strand == query_strand %>% trimws, ] %>% 
            .[which(.$end >= ((query_start %>% as.numeric) + left_query_shift - left_tolerance) & .$start <= ((query_end %>% as.numeric) + right_query_shift + right_tolerance)), ] %>% 
            .[which(.$type == return_type), ]
        
    }
    
    return(tibble_gtf_subset_matching_exons)
    
}

## END extract_overlapping_features() ###

```

```{r}

# FUNCTION TO EXTRACT COMMON STRING FROM TWO INPUT STRINGS IN ONE STEP, A SIMPLIFICATION OF QUALV

extract_common_string <- function(input_string_a, input_string_b) {
  
  # debug ###
  # 
  # input_string_a <- "ud_absolute.psi_1"
  # input_string_b <- "ud_absolute.psi_2"
  
  ###########
  
  vector_of_letters_a <- strsplit(input_string_a, "") %>% unlist
  vector_of_letters_b <- strsplit(input_string_b, "") %>% unlist 

  raw_LCS <- qualV::LCS(vector_of_letters_a, vector_of_letters_b)
  vector_common_string <- raw_LCS$LCS %>% paste(collapse = "")
  
  return(vector_common_string)
    
}

# END extract_common_string()

# FUNCTION TO TAKE THE AVERAGE VALUE OF A MATRIX OF TIMEPOINTS WITH THREE REPLICATES EACH (3 column compartments at a time)
## replicates of the same timepoint must be all grouped together.
calculate_average_values_from_replicate_columns <- function(input_matrix, number_of_replicates, append_average_to_column_name = TRUE) {
  
  # DEBUG ######
  
  # input_matrix <- wide_tibble_of_psisigma_results_allcomparisons_final_ud.only[, col_indices_observations]
  # number_of_replicates <- 3
  
  ##############
  
  # sanity check - if the number of columns is not an integer multiple of the number of replicates, there's something wrong
  if (ncol(input_matrix) %% number_of_replicates != 0) {
    
    stop("the number of columns in the matrix is not an integer multiple of the number of replicates specified. please check the matrix and try again.")
    
  }
  
  # get the row numbers to subset
  ## start of each compartment
  a <- seq(1, (ncol(input_matrix) - number_of_replicates + 1), number_of_replicates)
  ## end of each compartment
  b <- seq(number_of_replicates, ncol(input_matrix), number_of_replicates)
  # create list of compartments
  c <- purrr::map2(.x = a, .y = b, .f = ~.x:.y)
  # map each column into each compartment
  d <- purrr::map(.x = c, .f = ~input_matrix[, .x])
  # apply the average
  e <- purrr::map(.x = d, .f = ~apply(X = .x, MARGIN = 1, FUN = function(X){mean(X, na.rm = TRUE)}))
  # retrieve the column names of each compartment
  column_names <- purrr::map(.x = d, .f = ~colnames(.x) %>% purrr::reduce(extract_common_string))
  
  if (append_average_to_column_name == TRUE) {
    
    column_names <- paste(column_names, "average", sep = "")
    
  }
  
  # reframe into tibble, return
  f <- e %>% set_names(column_names) %>% as_tibble
  
}

# END calculate_average_values_from_replicate_columns()

```

### FUNCTION TO PLOT PCA FOR TIMEPOINT AND REPLICATE

```{r}

plot_PCA_for_timepoint_and_replicate <- function(matrixtable, timepoint_order = NULL, replicate_order = NULL, plot_shapes = TRUE, text_labels = FALSE, point_or_label_size = 2, legend_position = "right", PCA_depths_y = NULL, PCA_depths_x = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL, width = 10, height = 10) {
  
  # DEBUG ###
  # matrixtable <- wide_tibble_matrix_processed_sorted_tibbles %>% as.data.frame
  # save_dir <- R_processing_results_dir
  # save_name <- "total_RNA"  # 
  # graph_title <- "Total RNA"  # 
  # timepoint_order <- long_tibble_processed_sorted_tibbles$sample_name %>% unique
  # replicate_order <- c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8")
  # width = 10
  # height = 10
  # PCA_depths_y = c(2, 3, 4)
  # PCA_depths_x = c(1, 2, 3)
  # text_labels <- FALSE
  # point_or_label_size <- 4
  ###########
  
  PCA_result <- prcomp(matrixtable)
  
  ## measure PC variance #
  PCA_stdev <- tibble("PC" = 1:(PCA_result[["sdev"]] %>% length), "stdev" = PCA_result[["sdev"]])
  
  PCA_variance <- tibble(PC = PCA_stdev$PC, variance = PCA_stdev$stdev ^ 2)
  PCA_variance <- add_column(PCA_variance, variance_explained = PCA_variance$variance/sum(PCA_variance$variance) * 100)
  
  ggplot(PCA_variance) + 
    geom_col(aes(x = PC, y = variance_explained, fill = PC)) +
    scale_fill_gradientn(colours = heat.colors(n = (PCA_result[["sdev"]] %>% length))) +
    ggtitle(paste("PCA variance distribution\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("PC") +
    ylab("Variance explained (%)") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica")) +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 45, height = 25, units = "cm") +
    ggsave(filename = paste(save_dir, "PCA_barplot_stdevs_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = 45, height = 25, units = "cm")
  
  ## measure PC loadings #
  ## column names of the matrix need to be split by a "|", like this: timepoint|replicatenumber
  PCA_loadings <- PCA_result[["rotation"]] %>% as_tibble(rownames = "sample")
  PCA_loadings <- add_column(PCA_loadings, "timepoint" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1") %>% factor(x = ., levels = timepoint_order), .after = "sample")
  PCA_loadings <- add_column(PCA_loadings, "replicatenumber" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2") %>% factor(x = ., levels = replicate_order), .after = "sample")
  PCA_loadings <- add_column(PCA_loadings, 
                             "condition_names" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\1"),
                             "replicate_names" = gsub(x = PCA_loadings$sample, pattern = "(.*)\\|(.*)", replacement = "\\2"), 
                             .after = "sample")
  # append cluster number according to the order of timepoints specified by the user
  PCA_loadings <- dplyr::left_join(PCA_loadings, tibble("condition_names" = levels(PCA_loadings$timepoint), "cluster_number" = 1:length(levels(PCA_loadings$timepoint))), by = "condition_names") %>% 
    dplyr::relocate(cluster_number, .after = "sample")
  
  
  # plot PCA for multiple depths all in one go.
  purrr::map2(.x = PCA_depths_x, .y = PCA_depths_y, .f = function(.x, .y) {
    
    pc_x <- .x
    pc_y <- .y
    
    ggplot(PCA_loadings) + 
      (if (text_labels == FALSE) {geom_point(aes(x = !!(paste("PC", pc_x, sep = "") %>% as.name), y = !!(paste("PC", pc_y, sep = "") %>% as.name), shape = replicatenumber, color = timepoint), size = point_or_label_size)} else if (text_labels == TRUE) {geom_text(aes(x = !!(paste("PC", pc_x, sep = "") %>% as.name), y = !!(paste("PC", pc_y, sep = "") %>% as.name), label = PCA_loadings$cluster_number, color = timepoint), size = point_or_label_size, position = position_dodge(width = 4))}) +
      scale_color_brewer(name = "Timepoint", palette = "Spectral", breaks = timepoint_order, limits = timepoint_order) +
      scale_shape_manual(name = "Replicate", values = 1:length(replicate_order)) +
      ggtitle(paste("PCA loadings\n", graph_title, sep = "")) +
      guides(size = FALSE) + 
      xlab(paste("PC", pc_x, " (", PCA_variance[pc_x, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      ylab(paste("PC", pc_y, " (", PCA_variance[pc_y, "variance_explained"] %>% signif(3), "%)", sep = "")) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica"), legend.position = legend_position) +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".pdf", sep = ""), device = "pdf", dpi = 600, width = width, height = height, units = "cm") +
      ggsave(filename = paste(save_dir, "PCA_loadings_", save_name, "_PC", pc_y, "_vs_PC_", pc_x, ".svg", sep = ""), device = "svg", dpi = 600, width = width, height = height, units = "cm")
    
  } )
  
}

```

### FUNCTION TO PLOT UMAP FOR TIMEPOINT AND REPLICATE

NOTE: the matrixtable must be transposed, with one row per variable.

```{r}

plot_UMAP_for_timepoint_and_replicate <- function(transposed_matrixtable, timepoint_order = NULL, replicate_order = NULL, plot_shapes = TRUE, centroid_labels = TRUE, point_size = 5, centroid_label_size = 4, legend_position = "none", PCA_depths_y = NULL, PCA_depths_x = NULL, input_colour_limits = NULL, input_colour_value = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL, width = 10, height = 10) {
  
  # DEBUG ###
  # transposed_matrixtable <- df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t
  # timepoint_order <- temp_condition_names
  # replicate_order <- c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8")
  # plot_shapes <- FALSE
  # legend_position <- "none"
  # centroid_labels <- TRUE
  # point_size <- 1
  # centroid_label_size <- 1
  # PCA_depths_y <- c(2, 3, 4)
  # PCA_depths_x <- c(1, 2, 3)
  # save_dir <- R_processing_results_dir
  # save_name <- "total_RNA_psisigma_pooled_replicates_no_na"
  # graph_title <- "Total RNA/PSI-Sigma"
  # width <- 40
  # height <- 40
  ###########
  
  tibble_umap_result <- umap::umap(transposed_matrixtable) %>% .$layout %>% 
    as_tibble(rownames = "condition|replicate", .name_repair = "unique") %>%
    setNames(nm = c("condition|replicate", "V1", "V2")) %>%
    add_column("condition_names" = gsub(x = .$`condition|replicate`, pattern = "(.*)\\|(.*)", replacement = "\\1"),
               "replicate_names" = gsub(x = .$`condition|replicate`, pattern = "(.*)\\|(.*)", replacement = "\\2")
               )
  
  # centroid labels: make a separate file containing the centroid locations
  tibble_centroid_locations <- tibble_umap_result %>% 
    dplyr::group_by(condition_names) %>% 
    dplyr::summarise("centroid_x" = mean(V1),
                     "centroid_y" = mean(V2)) %>%
    add_column("cluster_number" = paste(1:nrow(.)), .after = "condition_names")
  
  # append cluster info
  tibble_umap_result_plot <- dplyr::left_join(tibble_umap_result, tibble_centroid_locations, by = "condition_names")
  
  if (is.null(input_colour_limits) == TRUE) {
    
    input_colour_limits <- c(tibble_umap_result_plot$condition_names %>% unique)
    
  }
  
  if (is.null(input_colour_value) == TRUE) {
    
    input_colour_value <- rainbow(n = (timepoint_order %>% length))
    
  }
  
  # plot UMAP for multiple depths all in one go.
  ggplot() +
    (if (plot_shapes == TRUE) {geom_point(aes(x = tibble_umap_result_plot$V1, y = tibble_umap_result_plot$V2, shape = tibble_umap_result_plot$replicate_names, color = tibble_umap_result_plot$condition_names, fill = tibble_umap_result_plot$condition_names), size = point_size) } else {geom_blank(aes(x = tibble_umap_result_plot$V1, y = tibble_umap_result_plot$V2))}) +
    scale_shape_manual(name = "Replicate", values = 1:length(replicate_order)) +
    (if (centroid_labels == TRUE) {geom_text(aes(x = tibble_centroid_locations$centroid_x, y = tibble_centroid_locations$centroid_y, label = tibble_centroid_locations$cluster_number, color = tibble_centroid_locations$condition_names), size = centroid_label_size)} else {geom_blank(aes(x = tibble_centroid_locations$centroid_x, y = tibble_centroid_locations$centroid_y))}) +
    scale_fill_manual(name = "Timepoint", breaks = input_colour_limits, limits = input_colour_limits, values = input_colour_value) +
    scale_colour_manual(name = "Timepoint", breaks = input_colour_limits, limits = input_colour_limits, values = input_colour_value) +
    # scale_color_brewer(name = "Timepoint", palette = "Spectral", breaks = timepoint_order, limits = timepoint_order) +
    ggtitle(paste("UMAP projection\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("UMAP_1") +
    ylab("UMAP_2") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica"), legend.position = legend_position) +
    ggsave(filename = paste(save_dir, "UMAP_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = width, height = height, units = "cm") +
    ggsave(filename = paste(save_dir, "UMAP_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = width, height = height, units = "cm")
  
  write.table(x = tibble_centroid_locations, file = paste(save_dir, "UMAP_", save_name, "_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
  
}

```

### FUNCTION TO PLOT tSNE FOR TIMEPOINT AND REPLICATE

NOTE: the matrixtable must be transposed, with one row per variable.

```{r}

plot_tSNE_for_timepoint_and_replicate <- function(transposed_matrixtable, timepoint_order = NULL, replicate_order = NULL, plot_shapes = TRUE, centroid_labels = TRUE, point_size = 5, centroid_label_size = 4, legend_position = "none", PCA_depths_y = NULL, PCA_depths_x = NULL, input_colour_limits = NULL, input_colour_value = NULL, save_dir = NULL, save_name = NULL, graph_title = NULL, width = 10, height = 10) {
  
  # DEBUG ###
  # transposed_matrixtable <- wide_tibble_matrix_processed_sorted_tibbles %>% as.data.frame %>% t
  # save_dir <- R_processing_results_dir
  # save_name <- "total_RNA"
  # graph_title <- "Total RNA"
  # timepoint_order <- long_tibble_processed_sorted_tibbles$sample_name %>% unique
  # replicate_order <- c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8")
  # width <- 40
  # height <- 40
  # point_size <- 1
  # centroid_label_size <- 1
  # plot_shapes <- FALSE
  # centroid_labels <- TRUE
  # legend_position <- "none"
  ###########
  
  tibble_tsne_result <- Rtsne::Rtsne(X = transposed_matrixtable %>% unique, perplexity = 1, check_duplicates = FALSE, verbose = TRUE, num_threads = 0) %>% .$Y %>% 
    as_tibble(.name_repair = "unique") %>%
    add_column("condition_names" = rownames(transposed_matrixtable %>% unique), .before = 1) %>%
    setNames(nm = c("condition|replicate", "V1", "V2")) %>%
    add_column("condition_names" = gsub(x = .$`condition|replicate`, pattern = "(.*)\\|(.*)", replacement = "\\1"),
               "replicate_names" = gsub(x = .$`condition|replicate`, pattern = "(.*)\\|(.*)", replacement = "\\2")
    )
  
  # centroid labels: make a separate file containing the centroid locations
  tibble_centroid_locations <- tibble_tsne_result %>% 
    dplyr::group_by(condition_names) %>% 
    dplyr::summarise("centroid_x" = mean(V1),
                     "centroid_y" = mean(V2)) %>%
    add_column("cluster_number" = paste(1:nrow(.)), .after = "condition_names")
  
  # append cluster info
  tibble_tsne_result_plot <- dplyr::left_join(tibble_tsne_result, tibble_centroid_locations, by = "condition_names")
  
  if (is.null(input_colour_limits) == TRUE) {
    
    input_colour_limits <- c(tibble_tsne_result_plot$condition_names %>% unique)
    
  }
  
  if (is.null(input_colour_value) == TRUE) {
    
    input_colour_value <- rainbow(n = (timepoint_order %>% length))
    
  }
  
  # plot UMAP for multiple depths all in one go.
  ggplot() + 
    (if (plot_shapes == TRUE) {geom_point(aes(x = tibble_tsne_result_plot$V1, y = tibble_tsne_result_plot$V2, shape = tibble_tsne_result_plot$replicate_names, color = tibble_tsne_result_plot$condition_names, fill = tibble_tsne_result_plot$condition_names), size = point_size) } else {geom_blank(aes(x = tibble_tsne_result_plot$V1, y = tibble_tsne_result_plot$V2))}) +
    scale_shape_manual(name = "Replicate", values = 1:length(replicate_order)) +
    (if (centroid_labels == TRUE) {geom_text(aes(x = tibble_centroid_locations$centroid_x, y = tibble_centroid_locations$centroid_y, label = tibble_centroid_locations$cluster_number, color = tibble_centroid_locations$condition_names), size = centroid_label_size)} else {geom_blank(aes(x = tibble_centroid_locations$centroid_x, y = tibble_centroid_locations$centroid_y))}) +
    scale_fill_manual(name = "Timepoint", breaks = input_colour_limits, limits = input_colour_limits, values = input_colour_value) +
    scale_colour_manual(name = "Timepoint", breaks = input_colour_limits, limits = input_colour_limits, values = input_colour_value) +
    # scale_color_brewer(name = "Timepoint", palette = "Spectral", breaks = timepoint_order, limits = timepoint_order) +
    ggtitle(paste("tSNE projection\n", graph_title, sep = "")) +
    guides(size = FALSE) + 
    xlab("tSNE_1") +
    ylab("tSNE_2") +
    theme_bw() +
    theme(text = element_text(family = "Helvetica"), legend.position = legend_position) +
    ggsave(filename = paste(save_dir, "tSNE_", save_name, ".pdf", sep = ""), device = "pdf", dpi = 600, width = width, height = height, units = "cm") +
    ggsave(filename = paste(save_dir, "tSNE_", save_name, ".svg", sep = ""), device = "svg", dpi = 600, width = width, height = height, units = "cm")
  
  write.table(x = tibble_centroid_locations, file = paste(save_dir, "tSNE_", save_name, "_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
  
}

```

# create GTFs for dbPTM, interpro and biomart.

## declare variables 

```{r}

ensembl_GTF_dump_dir <- "/mnt/LTS/projects/2020_isoform_nomenclature/ENST_to_HGNC_stable_variant_mapping/"

interpro_archive_dir <- "/mnt/LTS/reference_data/interpro/database/ftp.ebi.ac.uk/pub/databases/interpro/"

uniprot_dir <- "/mnt/LTS/reference_data/uniprotswissprot/"

```

## Import Ensembl GTFs and get genome-relative coords.

```{r}

# UNIPARC
data.table::setDTthreads(threads = 16)
## import mapping of uniparc to uniprotkb_entry accession
tibble_uniparc_mapping_complete <- data.table::fread(file = paste(uniprot_dir, "uniparc_uniprotkb_entry_mapping_complete.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE) %>% as_tibble %>% setNames(c("uniparc_accession", "uniprotkb_entry"))

# import ensembl HGNC stable variant name mapping
tibble_hgnc_stable_variant_mapping <- data.table::fread(file = paste(ensembl_GTF_dump_dir, "latest_mapping_table.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE) %>% as_tibble

# get ENSG to latest combined gene name mappings
tibble_ENSG_to_latest_ensg_gene_name_combined_mapping0 <- tibble_hgnc_stable_variant_mapping[, c("gene_id", "ensembl_release_version", "ensg_gene_name_combined")] %>% unique

tibble_ENSG_to_latest_ensg_gene_name_combined_mapping1 <- tibble_ENSG_to_latest_ensg_gene_name_combined_mapping0 %>%
      dplyr::group_by(gene_id) %>%
      dplyr::mutate("last_release_seen" = max(ensembl_release_version))

tibble_ENSG_to_latest_ensg_gene_name_combined_mapping0 <- dplyr::left_join(
  tibble_ENSG_to_latest_ensg_gene_name_combined_mapping1,
  tibble_ENSG_to_latest_ensg_gene_name_combined_mapping1[tibble_ENSG_to_latest_ensg_gene_name_combined_mapping1$ensembl_release_version == tibble_ENSG_to_latest_ensg_gene_name_combined_mapping1$last_release_seen, c("gene_id", "ensg_gene_name_combined")] %>% dplyr::rename("latest_ensg_gene_name_combined" = "ensg_gene_name_combined")
)

tibble_ENSG_to_latest_ensg_gene_name_combined_mapping <- tibble_hgnc_stable_variant_mapping[, c("gene_id", "ENSG_historical_tree_order", "latest_ensg_gene_name_combined")] %>% unique

# uniprotkb_entry mapping using ENSG ###
tibble_uniprotkb_entry_to_ENSG <- dplyr::bind_rows(
  data.table::fread(file = paste(uniprot_dir, "idmapping.dat_ENSG", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE),
  data.table::fread(file = paste(uniprot_dir, "idmapping.dat.2015_03_ENSG", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE)
) %>% as_tibble %>% setNames(c("uniprotkb_entry", "gene_id")) %>% unique

# join uniparc info onto the ENSG mapping table
tibble_uniparc_uniprotkb_entry_ENSG <- dplyr::inner_join(tibble_uniparc_mapping_complete, tibble_uniprotkb_entry_to_ENSG) %>% 
  dplyr::left_join(., tibble_ENSG_to_latest_ensg_gene_name_combined_mapping)

options(mc.cores = 16)
# group by ENSG id and assign uniprotkb_entry accessions in ascending uniparc order
tibble_ENSG_ids_numbered_by_uniparc <- tibble_uniparc_uniprotkb_entry_ENSG %>% 
  dplyr::group_split(gene_id, latest_ensg_gene_name_combined) %>% 
  furrr::future_map(~.x %>% dplyr::arrange(uniprotkb_entry) %>% dplyr::arrange(uniparc_accession) %>% tibble::add_column("stable_uniprotkb_entry_number" = 1:nrow(.x))) %>% rbindlist %>% as_tibble

write.table(x = tibble_ENSG_ids_numbered_by_uniparc, file = paste(results_dir, "tibble_ENSG_ids_numbered_by_uniparc.txt", sep = ""), sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)
  
# uniprotkb_entry mapping using uniprotkb_id ###
tibble_uniprotkb_entry_to_uniprotkb_id <- dplyr::bind_rows(
  data.table::fread(file = paste(uniprot_dir, "idmapping.dat_uniprotkb_id_human", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE),
  data.table::fread(file = paste(uniprot_dir, "idmapping.dat.2015_03_uniprotkb_id_human", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE)
) %>% as_tibble %>% setNames(c("uniprotkb_entry", "uniprotkb_id")) %>% unique

# join uniparc info onto the ENSG mapping table
tibble_uniparc_uniprotkb_entry_ENSG <- dplyr::inner_join(tibble_uniparc_mapping_complete, tibble_uniprotkb_entry_to_uniprotkb_id)

options(mc.cores = 16)
# group by ENSG id and assign uniprotkb_entry accessions in ascending uniparc order
tibble_ENSG_ids_numbered_by_uniparc <- tibble_uniparc_uniprotkb_entry_ENSG %>% 
  dplyr::group_split(gene_id, latest_ensg_gene_name_combined) %>% 
  head %>%
  furrr::future_map(~.x %>% dplyr::arrange(uniprotkb_entry) %>% dplyr::arrange(uniparc_accession) %>% tibble::add_column("stable_uniprotkb_entry_number" = 1:nrow(.x))) %>% rbindlist %>% as_tibble





# fix interpro annotation before and including release 63
# furrr::future_imap(
#   .x = dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = TRUE) %>% .[1:21],
#   .f = function(a1, a2) {
#     
#     # DEBUG ###
#     # a1 <- dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = TRUE) %>% .[1:21] %>% .[[1]]
#     ###########
#     
#     print(a2)
#     
#     vector_input <- read.delim(file = paste(a1, "/entry.list", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE)
#     
#     # detect the lines where there is no "IPR". these are the heading rows.
#     vector_indices_headers <- which(!grepl(x = vector_input$V1, pattern = "^IPR\\d+"))
#     # accordingly, get the segment starts and ends and make tibble
#     vector_indices_segment_starts <- vector_indices_headers + 1
#     vector_indices_segment_ends <- c(vector_indices_headers[2:length(vector_indices_headers)] - 1, vector_input$V1 %>% length)
#     
#     tibble_output <- purrr::pmap(
#       .l = list(
#         "b1" = vector_indices_headers,
#         "b2" = vector_indices_segment_starts,
#         "b3" = vector_indices_segment_ends
#       ),
#       .f = function(b1, b2, b3) {
#         
#         # DEBUG ###
#         # b1 <- vector_indices_headers[1]
#         # b2 <- vector_indices_segment_starts[1]
#         # b3 <- vector_indices_segment_ends[1]
#         ###########
#         
#         tibble(
#           "ENTRY_AC" = vector_input$V1 %>% .[b2:b3] %>% gsub(pattern = "^([^ ]+) +(.*)", replacement = "\\1"),
#           "ENTRY_TYPE" = vector_input$V1 %>% .[b1],
#           "ENTRY_NAME" = vector_input$V1 %>% .[b2:b3] %>% gsub(pattern = "^([^ ]+) +(.*)", replacement = "\\2")
#         )
#         
#       } ) %>% dplyr::bind_rows()
#     
#     write.table(tibble_output, file = paste(a1, "/entry.fixed.list", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
#     
#   }, .progress = TRUE)

# retrieve ALL ensembl GTFs in order to get a map for protein IDs.
options(mc.cores = 24)

list_all_tibble_ref_gtf <- furrr::future_map(
  .x = list.files(path = ensembl_GTF_dump_dir, pattern = "annotated_ensembl_gtf_release", full.names = TRUE),
  .f = ~read.delim(file = .x, sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE) %>% as_tibble
) %>% set_names(nm = list.files(path = ensembl_GTF_dump_dir, pattern = "annotated_ensembl_gtf_release", full.names = FALSE))

tibble_all_ref_gtfs <- list_all_tibble_ref_gtf %>% rbindlist(use.names = TRUE, fill = FALSE) %>% as_tibble

# 38.98 only
tibble_ref_gtf <- list_all_tibble_ref_gtf$annotated_ensembl_gtf_release_98.txt

options(mc.cores = 8)
#### get all the genome-relative positions of CDS nucleotides for every ENSP id
tibble_ENSP_to_genome_relative_CDS_positions <- tibble_ref_gtf %>%
  dplyr::filter(type == "CDS") %>%
  dplyr::group_split(transcript_id, transcript_version, protein_id, protein_version) %>%
  future_map(.f = ~list("transcript_id" = .x$transcript_id %>% unique, "transcript_version" = .x$transcript_version %>% unique, "protein_id" = .x$protein_id %>% unique, "protein_version" = .x$protein_version %>% unique, "seqnames" = .x$seqnames %>% unique, "strand" = .x$strand %>% unique, "vec_all_parent_ENSP_CDS_positions_sorted" = purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% sort), .progress = TRUE) %>%
  future_map(.f = ~as_tibble(.x) %>% nest(data = "vec_all_parent_ENSP_CDS_positions_sorted") %>% dplyr::rename("vec_all_parent_ENSP_CDS_positions_sorted" = "data"), .progress = TRUE) %>%
  rbindlist %>% as_tibble

# get ENSG to uniprotkb_entry mapping
## fetch uniprotkb_entry to ENSG mapping
tibble_ENSG_to_uniprotkb_entry <- dplyr::bind_rows(
  read.delim(file = paste(uniprot_dir, "idmapping.dat_ENSG", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE),
  read.delim(file = paste(uniprot_dir, "idmapping.dat.2015_03_ENSG", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE)
) %>% as_tibble %>% 
  setNames(c("uniprotkb_entry", "gene_id")) %>% unique
## add the latest ensg_gene_name_combined
## NOTE: this will yield more than one possible gene name for some uniprotkb_entries. we will have to pick the lowest one later on.
tibble_ENSG_to_uniprotkb_entry <- dplyr::left_join(tibble_ENSG_to_uniprotkb_entry, tibble_ENSG_to_latest_ensg_gene_name_combined_mapping)

# also import uniprotkb ID (NOT entry!) mappings
tibble_ENSP_to_uniprotkb_id <- read.delim(file = paste(uniprot_dir, "HUMAN_9606_idmapping.uniprotkbid.dat", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE) %>% as_tibble %>% 
  setNames(c("uniprotkb_entry", "uniprotkb_id")) 

# map to uniprot to get uniprot variant number, and get the gene name from the hgnc stable variant ID.
tibble_HGNC_ENSP_uniprotkb_entry_id0 <- dplyr::left_join(
  tibble_ENSP_to_uniprotkb_entry %>% dplyr::rename("protein_id" = "ensembl_peptide_id"),
  tibble_all_ref_gtfs[, c("protein_id", "protein_version", "ENSG_historical_tree_order", "latest_ensg_gene_name_combined")] %>% .[!is.na(.$protein_id) & !is.na(.$latest_ensg_gene_name_combined), ] %>% unique
) 

tibble_HGNC_ENSP_uniprotkb_entry_id <- dplyr::left_join(
  tibble_HGNC_ENSP_uniprotkb_entry_id0,
  tibble_ENSP_to_uniprotkb_id
)

# create hgnc_stable_variant_ID (uniprot-based)
tibble_HGNC_ENSP_uniprotkb_entry_id <- tibble_HGNC_ENSP_uniprotkb_entry_id %>% 
  dplyr::mutate(
    "hgnc_stable_variant_ID" = paste(latest_ensg_gene_name_combined, "-u", uniprot_isoform_number, sep = ""),
    "uniprot_stable_variant_ID" = paste(uniprotkb_id, "-u", uniprot_isoform_number, sep = ""))

write.table(x = tibble_HGNC_ENSP_uniprotkb_entry_id, file = paste(results_dir, "tibble_HGNC_ENSP_uniprotkb_entry_id.txt", sep = ""), sep = "\t", quote = FALSE, col.names = TRUE, row.names = FALSE)

```

## Import interpro annotation

```{r}

# fix interpro annotation before and including release 63
# furrr::future_imap(
#   .x = dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = TRUE) %>% .[1:21],
#   .f = function(a1, a2) {
#     
#     # DEBUG ###
#     # a1 <- dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = TRUE) %>% .[1:21] %>% .[[1]]
#     ###########
#     
#     print(a2)
#     
#     vector_input <- read.delim(file = paste(a1, "/entry.list", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = FALSE)
#     
#     # detect the lines where there is no "IPR". these are the heading rows.
#     vector_indices_headers <- which(!grepl(x = vector_input$V1, pattern = "^IPR\\d+"))
#     # accordingly, get the segment starts and ends and make tibble
#     vector_indices_segment_starts <- vector_indices_headers + 1
#     vector_indices_segment_ends <- c(vector_indices_headers[2:length(vector_indices_headers)] - 1, vector_input$V1 %>% length)
#     
#     tibble_output <- purrr::pmap(
#       .l = list(
#         "b1" = vector_indices_headers,
#         "b2" = vector_indices_segment_starts,
#         "b3" = vector_indices_segment_ends
#       ),
#       .f = function(b1, b2, b3) {
#         
#         # DEBUG ###
#         # b1 <- vector_indices_headers[1]
#         # b2 <- vector_indices_segment_starts[1]
#         # b3 <- vector_indices_segment_ends[1]
#         ###########
#         
#         tibble(
#           "ENTRY_AC" = vector_input$V1 %>% .[b2:b3] %>% gsub(pattern = "^([^ ]+) +(.*)", replacement = "\\1"),
#           "ENTRY_TYPE" = vector_input$V1 %>% .[b1],
#           "ENTRY_NAME" = vector_input$V1 %>% .[b2:b3] %>% gsub(pattern = "^([^ ]+) +(.*)", replacement = "\\2")
#         )
#         
#       } ) %>% dplyr::bind_rows()
#     
#     write.table(tibble_output, file = paste(a1, "/entry.fixed.list", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
#     
#   }, .progress = TRUE)

options(mc.cores = 8)

list_all_tibble_interpro_entries <- furrr::future_imap(
  .x = dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = TRUE),
  .f = function(a1, a2) {
    
    print(a2)
    
    read.delim(file = paste(a1, "/entry.fixed.list", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE) %>% as_tibble
    
  },
  .progress = TRUE) %>% 
  set_names(nm = dir(path = interpro_archive_dir, pattern = "\\d+\\.\\d+", full.names = FALSE))

# roll with one release for now
tibble_interpro_entry_mapping <- list_all_tibble_interpro_entries$`76.0`

```

## Import dbPTM 

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 16)))

# import dbPTM info
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/LTS/reference_data/dbPTM/extract/allPTM_human_filtered.txt", col.names = c("uniprotkb_entry", "_entryname", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# FIRST need to check that the modified AA is correct. 
# SECONDLY, after verifying it's correct, we will use the dbPTM able with modified residue info column
# import the Trembl fasta file
tibble_trembl_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/LTS/reference_data/uniprotswissprot/uniprot_trembl_humanonly.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
  furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
  unlist(use.names = TRUE) %>%
  tibble::enframe(name = "fasta_header", value = "sequence")

# import the swissprot canonical fasta file
list_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/LTS/reference_data/uniprotswissprot/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE)

tibble_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/LTS/reference_data/uniprotswissprot/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
  furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
  unlist(use.names = TRUE) %>%
  tibble::enframe(name = "fasta_header", value = "sequence")

# import the swissprot isoforms fasta file
tibble_sp.isoforms_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/LTS/reference_data/uniprotswissprot/uniprot_sprot_isoforms_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
  furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
  unlist(use.names = TRUE) %>%
  tibble::enframe(name = "fasta_header", value = "sequence")

# extract the entry ID column
# tibble_sp.canonical_fasta_allhuman
# tibble_sp.isoforms_fasta_allhuman
# tibble_trembl_fasta_allhuman
tibble_sp.trembl_fasta_allhuman_processed <- dplyr::bind_rows(tibble_sp.canonical_fasta_allhuman, tibble_sp.isoforms_fasta_allhuman, tibble_trembl_fasta_allhuman) %>%
  dplyr::mutate("uniprotkb_entry" = gsub(x = `fasta_header`, pattern = ".*\\|(.*)\\|.*", replacement = "\\1"))

# table join
tibble_sp.trembl_fasta_with_dbPTM_annotation <- dplyr::left_join(tibble_sp.trembl_fasta_allhuman_processed, tibble_dbPTM_allhuman_annotations, by = "uniprotkb_entry") %>% .[-which(is.na(.$PTM_type)), ]

# retrieve amino acid residue for each PTM type
list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type <- tibble_sp.trembl_fasta_with_dbPTM_annotation %>%
  dplyr::group_split(PTM_type) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 4)))

# map thru the list
list_sp.trembl_residues_per_PTM_type <- furrr::future_map(
  .x = list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type,
  .f = function(a1) {

    # DEBUG ###
    # a1 <- list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type$Phosphorylation
    ###########
    
    tibble0 <- a1 %>% 
      dplyr::mutate(
        "modified_residue_minus_1" = purrr::map2(.x = a1$sequence %>% strsplit(split = ""), .y = a1$modified_residue_position - 1, .f = ~.x[.y]) %>% unlist,
        "modified_residue" = purrr::map2(.x = a1$sequence %>% strsplit(split = ""), .y = a1$modified_residue_position, .f = ~.x[.y]) %>% unlist,
        "modified_residue_plus_1" = purrr::map2(.x = a1$sequence %>% strsplit(split = ""), .y = a1$modified_residue_position + 1, .f = ~.x[.y]) %>% unlist)
    
    return(tibble0)

  }, .progress = TRUE)

# list_of_tally_tibbles_per_residue_minus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_minus_1) %>% dplyr::summarise("tally_minus_1" = n()) %>% dplyr::arrange(desc(tally_minus_1)))
list_of_tally_tibbles_per_residue <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally)))
# list_of_tally_tibbles_per_residue_plus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_plus_1) %>% dplyr::summarise("tally_plus_1" = n()) %>% dplyr::arrange(desc(tally_plus_1)))

# tibblise
tibble_dbPTM_with_modified_residue <- list_sp.trembl_residues_per_PTM_type %>% rbindlist %>% as_tibble %>% dplyr::select(uniprotkb_entry, `_entryname`, modified_residue_position, PTM_type, modified_residue) %>% 
  dplyr::mutate(
    "uniprot_isoform_number" = gsub(x = uniprotkb_entry, pattern = "^([^\\-]+)(\\-(.*))*", replacement = "\\2") %>% gsub(pattern = "\\-", replacement = "") %>% type.convert,
    "uniprotkb_entry" = gsub(x = uniprotkb_entry, pattern = "^([^\\-]+)(\\-(.*))*", replacement = "\\1")
  )

tibble_dbPTM_with_modified_residue[is.na(tibble_dbPTM_with_modified_residue$uniprot_isoform_number), "uniprot_isoform_number"] <- 1

```

## cast protein regions onto the genome

### Interpro and BioMart

```{r}

plan(list(tweak(multiprocess, workers = 24),
          tweak(multiprocess, workers = 4)))

list_biomart_features <- furrr::future_map(
  .x = list(
    "interpro" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "interpro", "interpro_start", "interpro_end"),
    "mobidblite" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "mobidblite_start", "mobidblite_end"),
    "ncoils" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "ncoils_start", "ncoils_end"),
    "seg" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "seg_start", "seg_end"),
    "signalp" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "signalp_start", "signalp_end"),
    "tmhmm" = c("ensembl_peptide_id", "ensembl_peptide_id_version", "tmhmm_start", "tmhmm_end")
  ),
  .f = ~getBM(attributes = .x, mart = ensembl_mart) %>% as_tibble,
  .progress = TRUE)

list_biomart_features <- list_biomart_features %>% purrr::map(~.x %>% dplyr::mutate("ensembl_transcript_version" = gsub(x = `ensembl_transcript_id_version`, pattern = ".*\\.(.*)$", replacement = "\\1"), "ensembl_peptide_version" = gsub(x = `ensembl_peptide_id_version`, pattern = ".*\\.(.*)$", replacement = "\\1")) %>% dplyr::select(-ensembl_transcript_id_version, -ensembl_peptide_id_version) %>% na.omit)

# rename columns of each nested tibble to be consistent
list_biomart_features <- list_biomart_features %>% purrr::map(.f = function(.x) {
    
    output_tibble <- .x
    
    colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
    colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
    
    return(output_tibble)
    
} )

# add the interpro entry info 
list_biomart_features$interpro <- dplyr::left_join(
  list_biomart_features$interpro, 
  tibble_interpro_entry_mapping %>% dplyr::rename("interpro" = "ENTRY_AC"))

plan(list(tweak(multiprocess, workers = 6),
          tweak(multiprocess, workers = 16))
)

list_of_tibbles_biomart_regions_cast_onto_genome <- furrr::future_imap(
  .x = list_biomart_features, 
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_biomart_features$interpro
    ###########
    
    cat("\nnow processing: ", a2, "\n")
    
    tibble_sorted_CDS_relative_positions <- a1 %>% 
      add_column("CDS_relative_coords_start" = ((3*.$start) - 2), "CDS_relative_coords_end" = (3*.$end)) %>% 
      dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
      dplyr::rename("protein_id" = "ensembl_peptide_id") %>%
      dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions) %>%
      # some ENSP ids from interpro are not in ensembl.
      dplyr::filter(is.na(seqnames) != TRUE) 
    
    # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
    # these are the regions casted onto the genome.
    vec_all_genome_relative_coords_of_item <- future_map2(
        .x = tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions`, 
        .y = tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted`, 
        .f = function(b1, b2) {
            
            # DEBUG ###
            # b1 <- tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions` %>% .[[1]]
            # b2 <- tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted` %>% .[[1]]
            ###########
            
            vec_parent_ENSP_CDS_positions <- b2 %>% unlist
            
            vec_parent_ENSP_CDS_positions[b1] %>% return
            
        }, .progress = TRUE)
    
    nucleotide_width <- purrr::map(.x = vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist
    
    # add the genome-relative coords and nucleotide width in
    final_tibble_with_genome_relative_coords <- tibble_sorted_CDS_relative_positions %>% 
        add_column("vec_all_genome_relative_coords_of_item" = vec_all_genome_relative_coords_of_item,
                   "nucleotide_width" = nucleotide_width)
    
    return(final_tibble_with_genome_relative_coords)
    
}, .progress = TRUE ) 

```


### dbPTM

```{r}

# convert uniprotkb_entry into ENSP
tibble_dbPTM_allhuman_annotations_with_ENSP <- dplyr::left_join(tibble_dbPTM_with_modified_residue, tibble_HGNC_ENSP_uniprotkb_entry_id, by = "uniprotkb_entry") %>% 
  dplyr::filter(is.na(protein_id) != TRUE) %>% type_convert

# shorten the PTM type names
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Acetylation", "PTM_type"] <- "ac"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Amidation", "PTM_type"] <- "conh"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == c("C-linked Glycosylation"), "PTM_type"] <- "c-gly"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Carbamidation", "PTM_type"] <- "cbam"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Carboxylation", "PTM_type"] <- "coo"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Citrullination", "PTM_type"] <- "cit"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Crotonylation", "PTM_type"] <- "ctn"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Gamma-carboxyglutamic acid", "PTM_type"] <- "gla"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Glutarylation", "PTM_type"] <- "glu"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Glutathionylation", "PTM_type"] <- "gsh"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "GPI-anchor", "PTM_type"] <- "gpia"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Hydroxylation", "PTM_type"] <- "oh"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Lipoylation", "PTM_type"] <- "la"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Malonylation", "PTM_type"] <- "mal"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Methylation", "PTM_type"] <- "me"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Myristoylation", "PTM_type"] <- "myr"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "N-linked Glycosylation", "PTM_type"] <- "n-gly"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Neddylation", "PTM_type"] <- "nedd"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Nitration", "PTM_type"] <- "nit"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "O-linked Glycosylation", "PTM_type"] <- "o-gly"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Oxidation", "PTM_type"] <- "ox"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Palmitoylation", "PTM_type"] <- "palm"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Phosphorylation", "PTM_type"] <- "p"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Pyrrolidone carboxylic acid", "PTM_type"] <- "pca"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Pyruvate", "PTM_type"] <- "pyr"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == c("S-linked Glycosylation"), "PTM_type"] <- "s-gly"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type %in% c("S-nitrosylation", "S-Nitrosylation"), "PTM_type"] <- "s-nitr"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Succinylation", "PTM_type"] <- "succ"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Sulfation", "PTM_type"] <- "sulf"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Sumoylation", "PTM_type"] <- "sumo"
tibble_dbPTM_allhuman_annotations_with_ENSP[tibble_dbPTM_allhuman_annotations_with_ENSP$PTM_type == "Ubiquitination", "PTM_type"] <- "ub"

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 1)))
# cast onto genome.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_with_ENSP %>% 
  add_column("CDS_relative_coords_start" = ((3*.$modified_residue_position) - 2), "CDS_relative_coords_end" = (3*.$modified_residue_position)) %>% 
  dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
  dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions) %>%
  # some ENSP ids from interpro are not in ensembl.
  dplyr::filter(is.na(seqnames) != TRUE) %>%
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  dplyr::mutate("vec_all_genome_relative_coords_of_item" = furrr::future_map2(.x = .$vec_all_CDS_relative_positions, .y = .$vec_all_parent_ENSP_CDS_positions_sorted, .f = ~.y %>% unlist %>% .[.x], .progress = TRUE)) %>%
  dplyr::mutate("nucleotide_width" = purrr::map(.x = .$vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist)

# drop the columns of all ENSP positions. we dont need them anymore.
tibble_dbPTM_allhuman_annotations_cast_onto_genome_subset <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>% dplyr::select(transcript_id, transcript_version, uniprotkb_entry, PTM_type, modified_residue_position, modified_residue, protein_id, protein_version, seqnames, strand, vec_all_genome_relative_coords_of_item, nucleotide_width)

# create GTF 
## sample an exon row from the GTF
# tibble_gtf_row_sample <- tibble_ref_gtf[tibble_ref_gtf$type == "exon", ] %>% .[1, ]

## subset by protein (+ version) in order to create a "transcript" of all its PTMs.
list_dbPTM_GTF_subset_by_transcript_id <- tibble_dbPTM_allhuman_annotations_cast_onto_genome_subset %>% 
  dplyr::rowwise() %>%
  dplyr::group_split()

list_dbPTM_GTF_subset_by_transcript_id <- purrr::map(
  .x = list_dbPTM_GTF_subset_by_transcript_id,
  .f = function(a1) {
    
    # DEBUG ###
    a1 <- list_dbPTM_GTF_subset_by_transcript_id[[1]]
    ###########
    
    vector_genome_relative_feature_positions <- a1$vec_all_genome_relative_coords_of_item %>% unlist %>% sort
    
    # convert the individual nt positions to a set of ranges
    ## achieve this by comparing n to n + 1
    ## for rows where diff > 1, the n represents the end of an exon. n.plus.1 represents the start of the exon right after the gap.
    tibble_n_n.plus.1 <- tibble("n" = vector_genome_relative_feature_positions %>% head(n = length(vector_genome_relative_feature_positions) - 1),
                                "n.plus.1" = vector_genome_relative_feature_positions %>% .[2:length(vector_genome_relative_feature_positions)]) %>% 
      add_column("difference" = .$n.plus.1 - .$n)
    
    ## if there are no gaps, then just take the genomic range as the start:end
    if (tibble_n_n.plus.1$difference %>% unique %>% length == 1) {
      
      vec_starts <- min(vector_genome_relative_feature_positions)
      vec_ends <- max(vector_genome_relative_feature_positions)
      vec_widths <- vec_end - vec_start + 1
      
    } else if (tibble_n_n.plus.1$difference %>% unique %>% length > 1) {
      
      # vec_blockCount <- tibble_n_n.plus.1$difference %>% unique %>% length
      vec_starts <- c(first(vector_genome_relative_feature_positions), 
                           tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n.plus.1"] %>% unlist(use.names = FALSE))
      vec_ends <- c(tibble_n_n.plus.1[tibble_n_n.plus.1$difference > 1, "n"] %>% unlist(use.names = FALSE), 
                         last(vector_genome_relative_feature_positions))
      vec_widths <- vec_ends - vec_starts + 1
      
    }
    
    tibble_gtf_entries <- a1 %>%
      dplyr::select(-vec_all_genome_relative_coords_of_item, -nucleotide_width) %>%
      dplyr::bind_cols(
        .,
        tibble(
        "start" = vec_starts,
        "end" = vec_ends,
        "width" = vec_widths,
        "type" = "exon") )
    
  } )



```


## RNA expression section

### define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

### import expression tables of DE genes

```{r}

logCPM_OBseries_anysig_DEGs_dir <- "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_1_original/R_processing_results/table_edgeR_GLM_DEGs_logCPM.txt"

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

# load(file = paste(results_dir, "ENSG_to_genesymbol_DEGs.dataframe", sep = ""))

# ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs_import %>% average_counts_from_triplicate(., no_annotation_cols = 2)

```

## JUM/PSI-Sigma section

### set global vars.

```{r}

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

UNION_junc_coor_path <- "/mnt/4tb_ironwolf/PGNEXUS_OBseries/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

tibble_RSEM_edgeR_DEGs_all_GO <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_RSEM/run_1_original/R_processing_results/table_hypergoresult_allDEGs_allGO.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### Import differential/constitutive/all detected tables

```{r}

# JUM ###
# tibble_JUM_5x5_som_clustered <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_5x5_som_clustered <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_906_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_869_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_330_differential_VSRs_qvalue0.01_dPSI0.15_with_na_ud.6h.1d_only.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = c("NA", "n/a", "", "na")) %>% as_tibble
# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

# tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7855_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7913_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

# tibble_JUM_all_junctions_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_all_junctions_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_5x5_som_clustered <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_5x5_som_clustered <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_ud.6h.1d_only <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_43LIVs_scaled.PSI_OB_diff_MSC_6h_1d.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = c("NA", "n/a", "", "na")) %>% as_tibble

# tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# tibble_PSIsigma_all_exons_with_na <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_all_exons_with_na <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import gene ontology enrichment tables

```{r}

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented GO terms for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented families for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_GOterms_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_PFAM_families_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import junction/exon ontology supporting info

```{r}

# JUM ###
# tibble_JUM_junction_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_supp_info <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/R_processing_results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_supp_info <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_exon_ontology_unmatched_items <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_unmatched_exons_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### Import junction/exon ontology tables

```{r}

# JUM ###
# tibble_JUM_junction_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_PTM <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_transcripts <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_biomart <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_PTMs <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_transcripts <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_biomart <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_PTMs <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_JUM_junction_ontology_biomart_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_interpro_domains_differential_junctions_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_JUM" = "genes", "tally_JUM" = "tally")
tibble_JUM_junction_ontology_PTMs_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_PTMs_differential_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_JUM" = "tally")

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_transcripts <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_biomart <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_PTMs <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_PSIsigma_exon_ontology_biomart_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_interpro_domains_differential_exons_15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_PSIsigma" = "genes", "tally_PSIsigma" = "tally")
tibble_PSIsigma_exon_ontology_PTMs_plots <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_PTMs_differential_dpsi15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_PSIsigma" = "tally")

```


## import public CLIP-Seq data and match with GTF information

### set directories

```{r}

clipseq_dir <- "/mnt/Tertiary/sharedfolder/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "/mnt/4tb_ironwolf/2019_FLASHseq/results/R_processing_results/"

# import chainfile
chainfile_hg19_to_hg38 <- rtracklayer::import.chain(con = ucsc_hg19_to_hg38_chainfile_path)

```

### Import coordinate level CLIP-Seq data

#### FLASH-Seq: SRSF1/2/3/4/5/6/7/9/11

```{r}

list_FLASHseq_tibbles_hg19 <- purrr::map(
  .x = list.files(path = FLASHseq_dir, pattern = paste(".*bed_annotated.*", sep = "")),
  .f = function(a1) {
    
    read.delim(paste(FLASHseq_dir, a1, sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% 
      as_tibble %>%
      dplyr::rename("chr" = "feature_chr", "start" = "feature_start", "end" = "feature_end") %>% 
      return
    
  } ) %>%
  set_names(c(
    "SRSF1 FLASH GSE118265",
    "SRSF2 FLASH GSE118265",
    "SRSF3 FLASH GSE118265",
    "SRSF4 FLASH GSE118265",
    "SRSF5 FLASH GSE118265",
    "SRSF6 FLASH GSE118265",
    "SRSF7 FLASH GSE118265",
    "SRSF9 FLASH GSE118265",
    "SRSF11 FLASH GSE118265"
  ))

# CONVERT FROM hg19 TO hg38 ###
list_FLASHseq_tibbles_hg38 <- purrr::map(
  .x = list_FLASHseq_tibbles_hg19,
  .f = ~rtracklayer::liftOver(x = .x %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% 
                                regioneR::toGRanges(),
                              chain = chainfile_hg19_to_hg38) %>%
    as_tibble %>%
    dplyr::select(-group, -group_name) %>%
    dplyr::rename("chr" = "seqnames") %>% 
    dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) )
  
```

#### SRSF2 (GSE111900)

```{r}

tibble_GSE111900_SRSF2_coord_info <- read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/GSE111900_srsf2_wt_hits.clip_coord_info.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

# split the genomic coords into chr start and end
tibble_peakfile_SRSF2_hits.clip_GSE111900_HEL_p0.01 <- tibble_GSE111900_SRSF2_coord_info %>% 
  dplyr::mutate("chr" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):.*", replacement = "\\1"),
                "start" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-.*", replacement = "\\2"),
                "end" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-(.*)", replacement = "\\3")) %>%
  dplyr::filter(clip_FDR <= 0.01)

```

#### HNRNPA1 (ENCODE)

```{r}

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### HNRNPA2B1 (GSM1716538)

```{r}

`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_filtered` <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19.bedgraph", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "height")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>%
  dplyr::filter(height > 20)

# `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_raw` <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19.bedgraph", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
#   setNames(c("chr", "start", "end", "height")) %>%
#   dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>%

# fit <- MASS::fitdistr(`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_raw`$height, densfun = "normal")

# plot(density(`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_raw`$height))
# curve(dnorm(x, mean = fit$estimate[1], sd = fit$estimate[2]), add = TRUE, col = "red")

# pnorm(20, mean = fit$estimate[1], sd = fit$estimate[2], lower.tail = FALSE)

# CONVERT FROM hg19 TO hg38 ###
`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg38_height20` <- rtracklayer::liftOver(x = `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_filtered` %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(),
                                                                                                  chain = chainfile_hg19_to_hg38) %>%
  as_tibble %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "height")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

#### MBNL1 (GSE76486)

```{r}

`tibble_bedfile_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg38` <- rtracklayer::import(con = paste(clipseq_dir, "binding.sites_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg19.bed", sep = "")) %>% rtracklayer::liftOver(chain = chainfile_hg19_to_hg38) %>% 
  as_tibble %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "name", "score")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

#### PRPF4 (ENCODE)

```{r}

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### RBM15 (ENCODE)

```{r}

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_RBM15_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SFPQ (ENCODE)

```{r}

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SUGP2 (ENCODE)

```{r}

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### TRA2A (ENCODE)

```{r}

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_TRA2A_eclip_ENCODE_K562_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SNRPA (GSM4512295)

```{r}

tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered <- read.delim(paste(clipseq_dir, "peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19.csv", sep = ""), sep = ",", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE) %>% 
  as_tibble %>%
  dplyr::filter(l10p > -log10(0.01))

# CONVERT FROM hg19 TO hg38 ###
# + strand
tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg38_p0.01 <- 
  dplyr::bind_rows(
    rtracklayer::liftOver(
      x = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered %>% dplyr::filter(strand == "+") %>% dplyr::select(-strand) %>% as.data.frame %>% regioneR::toGRanges(),
      chain = chainfile_hg19_to_hg38) %>% as_tibble,
    rtracklayer::liftOver(
      x = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered %>% dplyr::filter(strand == "-") %>% dplyr::select(-strand) %>% as.data.frame %>% regioneR::toGRanges(),
      chain = chainfile_hg19_to_hg38) %>% as_tibble
  )  %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "l10p", "l2fc", "geneid", "genename", "region")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

### prepare geneset categories

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/geneset_srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
                                               
  "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

```

## scRNA-Seq section

### Import Sierra DTU test results

```{r}

# Cluster-wise, simplified
tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_clusterwise_all_simplified <- tibble_sierra_DTU_clusterwise_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

# Pair-wise between clusters, simplified
tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_pairwise_clusters_all_simplified <- tibble_sierra_DTU_pairwise_clusters_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

```

## Ago2 iCLIP dataset

```{r}

tibble_ago2_iclip_binding_sites <- read.delim("/mnt/4tb_ironwolf/miRNA_hMSC_TERT_OB_diff/iCLIP.hg38.miRNA_targets_MSC_diff_iCLIP_binding_sites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% 
  as_tibble %>% 
  dplyr::filter(chrom != "") %>%
  dplyr::mutate_at(.vars = "chrom", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} )

# split the iclip table by chromosome
list_ago2_iclip_binding_sites_by_chr <- tibble_ago2_iclip_binding_sites %>% 
  dplyr::group_split(chrom) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chrom %>% unique) %>% unlist)
# generate list of vectors of ago2 iCLIP binding site genome coords.
list_of_vectors_ago2_iclip_binding_site_genome_coords <- purrr::map(.x = list_ago2_iclip_binding_sites_by_chr,
                                                                    .f = ~purrr::map2(.x = .x$start,
                                                                                      .y = .x$stop,
                                                                                      .f = ~.x:.y)
)

```

## Proteome section

### Import files

```{r}

# maxquant time-series data for MSC, 6h and 1d.
# list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d
load(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/R_processing_results/list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d.Rlist")

list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d <- list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d %>% purrr::map_depth(.depth = 2, .f = ~.x %>% type_convert(na = c("NA", "n/a", "", "na")))

```

### Check the residue of dbPTM annotated phosphosites

We are going to confirm that the TREMBL ids used are correct.

```{r}

# plan(list(tweak(multiprocess, workers = 4),
#           tweak(multiprocess, workers = 16)))
# 
# # plan(multiprocess)
# # options(mc.cores = 8)
# 
# # import dbPTM info
# # Z:/dbPTM_download/extract/allPTM_human.txt
# tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# 
# # import the Trembl fasta file
# tibble_trembl_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_trembl_humanonly.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# # import the swissprot canonical fasta file
# list_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE)
# 
# tibble_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# # import the swissprot isoforms fasta file
# tibble_sp.isoforms_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_isoforms_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# 
# # extract the entry ID column
# # tibble_sp.canonical_fasta_allhuman
# # tibble_sp.isoforms_fasta_allhuman
# # tibble_trembl_fasta_allhuman
# tibble_sp.trembl_fasta_allhuman_processed <- dplyr::bind_rows(tibble_sp.canonical_fasta_allhuman, tibble_sp.isoforms_fasta_allhuman, tibble_trembl_fasta_allhuman) %>% 
#   dplyr::mutate("uniprotkb_entry" = gsub(x = `fasta_header`, pattern = ".*\\|(.*)\\|.*", replacement = "\\1"))
# 
# # table join 
# tibble_sp.trembl_fasta_with_dbPTM_annotation <- dplyr::left_join(tibble_sp.trembl_fasta_allhuman_processed, tibble_dbPTM_allhuman_annotations, by = "uniprotkb_entry") %>% .[-which(is.na(.$PTM_type)), ]
# 
# # retrieve amino acid residue for each PTM type
# list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type <- tibble_sp.trembl_fasta_with_dbPTM_annotation %>% 
#   dplyr::group_split(PTM_type) %>%
#   set_names(nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)
# 
# # map thru the list
# list_sp.trembl_residues_per_PTM_type <- furrr::future_map(
#   .x = list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type,
#   .f = function(a1) {
#     
#     # DEBUG ###
#     # a1 <- list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type$Phosphorylation
#     ###########
#     
#     list_with_modified_residue <- furrr::future_map(
#       .x = a1 %>% array_tree,
#       .f = function(b1) {
#         
#         # DEBUG ###
#         # b1 <- a1 %>% array_tree %>% .[[1]]
#         ###########
#         
#         vector_uniprot_AA_sequence <- b1$sequence %>% strsplit(split = "") %>% unlist
#         
#         modified_residue_minus_1 <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert) - 1]
#         
#         modified_residue <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert)]
#         
#         modified_residue_plus_1 <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert) + 1]
#         
#         return(purrr::splice(b1,
#                              "modified_residue_minus_1" = modified_residue_minus_1,
#                              "modified_residue" = modified_residue,
#                              "modified_residue_plus_1" = modified_residue_plus_1) %>%
#                  as_tibble)
#         
#       }, .progress = TRUE)
#     
#     tibble_with_modified_residue <- list_with_modified_residue %>% rbindlist %>% as_tibble
#     
#     return(tibble_with_modified_residue)
#     
#   }, .progress = TRUE) 
# 
# # list_of_tally_tibbles_per_residue_minus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_minus_1) %>% dplyr::summarise("tally_minus_1" = n()) %>% dplyr::arrange(desc(tally_minus_1)))
# list_of_tally_tibbles_per_residue <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally)))
# # list_of_tally_tibbles_per_residue_plus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_plus_1) %>% dplyr::summarise("tally_plus_1" = n()) %>% dplyr::arrange(desc(tally_plus_1)))

```

#### filter incorrect trembl and uniprot entries from dbPTM database.

```{r}

# list_residues_to_keep <- list(
#   "Acetylation" = c("K", "A", "S"), 
#   "Amidation" = LETTERS, 
#   "C-linked Glycosylation" = c("W"), 
#   "Carbamidation" = c("C"), 
#   "Carboxylation" = c("K"), 
#   "Citrullination" = c("R"), 
#   "Crotonylation" = c("K"), 
#   "Gamma-carboxyglutamic acid" = c("E"), 
#   "Glutarylation" = c("K"), 
#   "Glutathionylation" = c("C"), 
#   "GPI-anchor" = LETTERS, 
#   "Hydroxylation" = c("P", "K", "N"), 
#   "Lipoylation" = c("K"), 
#   "Malonylation" = c("K"), 
#   "Methylation" = c("R", "K"), 
#   "Myristoylation" = c("G"), 
#   "N-linked Glycosylation" = c("N"), 
#   "Neddylation" = c("K"), 
#   "Nitration" = c("Y"), 
#   "O-linked Glycosylation" = c("T", "S"), 
#   "Oxidation" = c("M"), 
#   "Palmitoylation" = c("C"), 
#   "Phosphorylation" = c("S", "T", "Y"), 
#   "Pyrrolidone carboxylic acid" = c("Q"), 
#   "Pyruvate" = c("S"), 
#   "S-linked Glycosylation" = c("C"), 
#   "S-nitrosylation" = c("C"), 
#   "S-Nitrosylation" = c("C"), 
#   "Succinylation" = c("K"), 
#   "Sulfation" = c("Y"), 
#   "Sumoylation" = c("K"), 
#   "Ubiquitination" = c("K", "L")
# )
# 
# list_dbPTM_filtered_entries_with_sp.trembl <- furrr::future_map2(
#   .x = list_sp.trembl_residues_per_PTM_type,
#   .y = list_residues_to_keep[names(list_sp.trembl_residues_per_PTM_type)],
#   .f = function(a1, a2) {
#     
#     output_tibble <- a1[a1$modified_residue %in% a2, ]
#     
#     return(output_tibble)
#     
#   }, .progress = TRUE)
# 
# # check whether the filtering worked
# list_of_tally_tibbles_per_residue_filtered <- list_dbPTM_filtered_entries_with_sp.trembl %>% purrr::map(~.x %>% dplyr::group_by(modified_residue) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally)))
# 
# # retrieve the filtered dbPTM information
# tibble_dbPTM_filtered_entries <- list_dbPTM_filtered_entries_with_sp.trembl %>% purrr::map(~.x %>% dplyr::select(-fasta_header, -sequence, -modified_residue_minus_1, -modified_residue,-modified_residue_plus_1)) %>%
#   rbindlist %>% as_tibble
# 
# # write the filtered dbPTM table
# write.table(x = tibble_dbPTM_filtered_entries, file = "/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

### Import all the non-homolog and non-superfamily entries from Interpro

```{r}

tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(reference_data_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

```

### Import the validated junc.exons as well as the validated phosphosites

```{r}

# tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_2020.PO4_valid_phosphosites <- read.delim("Z:/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons_checked_against_sp.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_unconfirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# we have to use all the non-validating PSI-Sigma exons because although they don't validate the RNA exon, they validate any coding regions contained in the differential exon.
tibble_2020.PO4_2012.proteome_valid_junc.exons_coding <- dplyr::bind_rows(
  tibble_2020.PO4_2012.proteome_valid_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons$Leading.razor.protein, pattern = "JUM", ignore.case = TRUE), ],
  tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons$Leading.razor.protein, pattern = "PSISigma", ignore.case = TRUE), ]
)

tibble_2020.PO4_valid_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble


```

#### Import the FASTA supplementary information

```{r}

tibble_fasta_supp_info_exons_differential_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_differential_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_exons_constitutive_ensembl <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_constitutive_strawberry <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_junctions_differential <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_differential_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_junctions_constitutive <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_constitutive_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# bind rows
tibble_fasta_supp_info_junctions <- dplyr::bind_rows(
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

tibble_fasta_supp_info_exons <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry
                                           )

tibble_fasta_supp_info <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry,
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

```

## SNP and disease section

### import GWAS catalog

```{r}

tibble_ebi_gwas_catalog <- read_tsv(file = "/mnt/4tb_ironwolf/eQTL_catalogue/gwas_catalog_v1.0.2-associations_e98_r2020-05-03.tsv", col_types = cols(.default = "c")) %>% 
  type_convert %>%
  dplyr::filter(CHR_ID %>% is.na == FALSE)

## Join the GWAS catalog with ensembl variation database

## Memo: we NEED this because we need to retrieve calculated consequences

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog$CHR_ID %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog$CHR_POS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog$SNPS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a5" = tibble_ebi_gwas_catalog$CONTEXT %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), grep(x = paste(tibble_ebi_gwas_catalog$CHR_POS, tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE`, tibble_ebi_gwas_catalog$SNPS, tibble_ebi_gwas_catalog$CONTEXT), pattern = "\\;")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\;"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\;") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\,")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\,"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\,") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which


tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\_")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\_"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\_") %>% dplyr::mutate_all(as.character))

# finally split by "x"'s due to gene interaction entries
rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$CHR_ID %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$CHR_POS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$`REGION` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$`REPORTED GENE(S)` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a5" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a6" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a7" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a8" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "x")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "x"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "REGION", "REPORTED GENE(S)", "MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "x") %>% dplyr::mutate_all(as.character))

tibble_ebi_gwas_catalog_deduped <- tibble_ebi_gwas_catalog_deduped %>% dplyr::mutate_all(.funs = trimws)

# list-ify by chromosome
list_tibble_ebi_gwas_catalog_by_chr <- tibble_ebi_gwas_catalog_deduped %>% 
  dplyr::mutate_at(.vars = "CHR_ID", .funs = trimws) %>%
  dplyr::group_split(CHR_ID) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$`CHR_ID` %>% unique) %>% unlist)

```

# JUM and PSI-Sigma analysis

## Calculate the number of junction/exons found in common

### Calculate intersections

STRATEGY: use one table to look up other table. one-directional evidence is required and sufficient for intersection.

#### FUNCTION TO CONVERT JUM AS_EVENT_ID TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

JUM_AS.event.ID_to_chr_strand_start_end <- function(tibble) {
  
  vec_AS.event.ID_unique <- tibble$AS_event_ID %>% unique
  
  vec_chr <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\2")
  vec_start <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\3")
  vec_end <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\5")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
  
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end))
  
}

```

#### FUNCTION TO CONVERT PSI-SIGMA DIFF_EXON_COORDS TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

PSIsigma_diff.exon.coords_to_chr_strand_start_end <- function(tibble) {
  
  vec_event.region.coords <- tibble$event_region_coords
  
  vec_chr <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- tibble$matched_strand
  vec_start <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\2")
  vec_end <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\3")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
    
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end) %>% unique)
  
}

```

#### create generic function to do this job.

```{r}

calculate_intersections_from_chr_strand_start_end <- function(tibble_1, tibble_2, tibble_1_tolerance_left, tibble_1_tolerance_right) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
  # tibble_1_tolerance_left <- 2
  # tibble_1_tolerance_right <- 2
  ###########
  
  tibble_1 <<- tibble_1
  tibble_2 <<- tibble_2
  
  # list-ify tibble_1
  list_tibble_1_array.tree <- tibble_1 %>% array_tree
  # set L1 names as identifier names
  names(list_tibble_1_array.tree) <- tibble_1$identifier
  
  # match each element of tibble_1 to tibble_2 and see if there is a valid subset found.
  list_tibble_1_to_2_matches <- future_map(.x = list_tibble_1_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_tibble_1_array.tree[[3]]
    ###########
    
    subset <- tibble_2[tibble_2$chr == .x$chr %>% paste %>% trimws, ] %>% 
      .[.$strand == .x$strand %>% paste %>% trimws, ] %>% 
      .[(.$start < (.x$end %>% paste %>% trimws %>% as.numeric) + tibble_1_tolerance_right) & (.$end > (.x$start %>% paste %>% trimws %>% as.numeric) - tibble_1_tolerance_left), ]
    
    if (nrow(subset) == 0) {
      return("no_overlap")
    } else {
      return(subset)
    }
    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_2", "tibble_1_tolerance_left", "tibble_1_tolerance_right")))
  
  # extract the list indices which had valid overlap
  vector_list.indices_with_valid_overlap <- list_tibble_1_to_2_matches %>% purrr::map(~all(.x == "no_overlap") == FALSE) %>% unlist %>% which
  # return aggregate number of overlap
  number_of_entries_with_valid_overlap <- vector_list.indices_with_valid_overlap %>% length
  # return summary list of matching table entries
  list_overlapped_table_entries <- future_imap(.x = list_tibble_1_to_2_matches[vector_list.indices_with_valid_overlap], .f = ~list("tibble_1_entry" = tibble_1[tibble_1$identifier == .y, ],
                                                                                                                                   "tibble_2_entry" = .x), .progress = TRUE, .options = future_options(globals = c("tibble_1")))
  
  return(list("number_of_entries_tibble_1" = nrow(tibble_1),
              "number_of_entries_tibble_2" = nrow(tibble_2),
              "number_of_common_entries" = number_of_entries_with_valid_overlap,
              "detailed_result" = list_overlapped_table_entries))
  
}

```

#### run the intersections

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na%>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

```

#### repeat the intersections with only genes in common

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_all_junctions_with_na %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% dplyr::rename("Gene" = "matched_gene_names"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na, tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::select(-matched_gene_names) %>% dplyr::rename("matched_gene_names" = "Gene"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

```

### Calculate gene-level spliceome intersections with expression

```{r}

# solo diff. spliced/expressed genes
cat(magenta("\nRSEM/EdgeR differential genes: ", logCPM_OBseries_anysig_DEGs$external_gene_name %>% unique %>% length))
cat(magenta("\nJUM differential genes: ", tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% length))
cat(magenta("\nPSI-Sigma differential genes: ", tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% length))

# JUM diff spliced vs. diff. expression
cat(magenta("\nJUM differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene) %>% unique %>% length))

# PSI-Sigma diff spliced vs. diff. expression
cat(magenta("\nPSI-Sigma differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# JUM diff spliced vs. PSI-Sigma diff spliced
cat(magenta("\nJUM differential genes vs. PSI-Sigma differential genes: ", intersect(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# fetch list of ALWAYS differentially spliced genes vs. ALWAYS constitutively spliced genes
vector_genes_differentially_spliced <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique
vector_genes_constitutively_spliced <- c(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$Gene, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[!tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %in% logCPM_OBseries_anysig_DEGs$external_gene_name, ] %>% .$splicemode %>% table %>% plot

vector_genes_both_diff_and_cons_spliced <- intersect(vector_genes_differentially_spliced, vector_genes_constitutively_spliced)
cat("vector_genes_both_diff_and_cons_spliced:", vector_genes_both_diff_and_cons_spliced %>% length)

vector_genes_differentially_spliced_only <- setdiff(vector_genes_differentially_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_differentially_spliced_only:", vector_genes_differentially_spliced_only %>% length)
vector_genes_constitutively_spliced_only <- setdiff(vector_genes_constitutively_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_constitutively_spliced_only:", vector_genes_constitutively_spliced_only %>% length)

```

## determine the genes in common per enrichment

### FUNCTION TO LOOK FOR OVERLAPS IN EACH GO-TERM BETWEEN TWO TABLES (GOhyperGall)

```{r}

extract_common_GOTerms_GOhyperGall <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: GOID, NodeSize, Term, Ont
  colnames(tibble_1)[c(3, 4, 5, 8)] <- paste(colnames(tibble_1)[c(3, 4, 5, 8)], "_1", sep = "")
  colnames(tibble_2)[c(3, 4, 5, 8)] <- paste(colnames(tibble_2)[c(3, 4, 5, 8)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("GOID", "NodeSize", "Term", "Ont"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$SampleKeys_1)), which(is.na(joined_tibble$SampleKeys_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
  # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$SampleKeys_1, .y = joined_tibble$SampleKeys_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### FUNCTION TO LOOK FOR OVERLAPS IN EACH ENRICHMENT BETWEEN TWO TABLES (bc3net::enrichment())

```{r}

extract_common_GOTerms_bc3net <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: c("TermID", "all")
  colnames(tibble_1)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_1)[c(2, 3, 4, 5, 6)], "_1", sep = "")
  colnames(tibble_2)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_2)[c(2, 3, 4, 5, 6)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("TermID"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$genes_contained_1)), which(is.na(joined_tibble$genes_contained_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
    # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$genes_contained_1, .y = joined_tibble$genes_contained_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### calculate intersections

```{r}

tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <-
  extract_common_GOTerms_GOhyperGall(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO, 
                                     tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO)

write.table(tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO, 
            paste(results_dir, "intersection_GOTerm_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <-
  extract_common_GOTerms_bc3net(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM, 
                                tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM)

write.table(tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM, 
            paste(results_dir, "intersection_PFAM_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

## Do GO enrichment (anysig) on both combined.

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, 
                                              tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% 
  strsplit(split = ",") %>% unlist %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat("\n", number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 900) %>% dplyr::filter(NodeSize < 1500) %>% dplyr::mutate_at(.vars = "Term", .funs = function(x) {stringr::str_trunc(string = x, side = "right", width = 78) %>% return}))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, -Phyper), y = -log10(Phyper))) +
  geom_col(aes(fill = SampleMatch)) +
  scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = 1, aesthetics = "fill", na.value = "yellow") +
  geom_hline(yintercept = -log10(0.05), lty = 2) +
  coord_flip() +
  facet_wrap(Ont ~ ., ncol = 3, scales = "free_y") +
  ggtitle(paste("Top 900 significantly over-represented GO terms for OB series for JUM and PSI-Sigma combined")) +
  xlab("GO term") +
  ylab(expression(log["10"](P))) +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(results_dir, "top_inf_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of geneset
write.table(x = vector_differential_genes_anysig_with_na, file = paste(results_dir, "geneset_OBseries_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
  
```

#### explore the kinases 

```{r}

vector_all_kinase_genes <- long_tibble_GO_test_anysig_with_na_top.hits[long_tibble_GO_test_anysig_with_na_top.hits$Term == "protein kinase activity", "SampleKeys"] %>% unlist %>% strsplit(split = " ") %>% unlist

# convert to ENSG
vector_all_kinase_ENSG <- getBM(attributes = "ensembl_gene_id", filters = "external_gene_name", values = vector_all_kinase_genes, mart = ensembl_mart) %>% unlist

# subset JUM and PSI-Sigma tibbles by kinase genes
tibble_JUM_differential_kinase_only <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %in% vector_all_kinase_genes, ]

tibble_JUM_differential_kinase_only %>% dplyr::group_by(splicemode) %>% dplyr::summarise(n())

tibble_PSIsigma_differential_kinase_only <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %in% vector_all_kinase_genes, ]

tibble_PSIsigma_differential_kinase_only %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% dplyr::group_by(splicemode) %>% dplyr::summarise(n())

# look at exon/junction ontology

tibble_JUM_junction_ontology_transcripts_kinase_only <- tibble_JUM_junction_ontology_transcripts[tibble_JUM_junction_ontology_transcripts$Gene %in% vector_all_kinase_genes, ] %>% split_delimited_columns_in_table(target_colname = "transcript_features", split = ",") %>% dplyr::group_by(transcript_features) %>% dplyr::summarise(n())
tibble_JUM_junction_ontology_biomart_kinase_only <- tibble_JUM_junction_ontology_biomart[tibble_JUM_junction_ontology_biomart$Gene %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::group_by(Gene) %>% dplyr::summarise("any_mobidblite" = mobidblite %>% is.na %>% all == FALSE, "any_seg" = mobidblite %>% is.na %>% all == FALSE, "any_interpro" = interpro %in% tibble_non_family_interpro_entries$Accession %>% any, "kinase_domain")

tibble_JUM_junction_ontology_biomart[tibble_JUM_junction_ontology_biomart$Gene %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::distinct(AS_event_ID, Name) %>% dplyr::group_by(Name) %>% dplyr::summarise(n())



tibble_JUM_junction_ontology_PTMs_kinase_only <- tibble_JUM_junction_ontology_PTMs[tibble_JUM_junction_ontology_PTMs$Gene %in% vector_all_kinase_genes, ] %>% dplyr::group_by(PTM_type) %>% dplyr::summarise(n())

tibble_PSIsigma_exon_ontology_transcripts_kinase_only <- tibble_PSIsigma_exon_ontology_transcripts[tibble_PSIsigma_exon_ontology_transcripts$matched_gene_names %in% vector_all_kinase_genes, ] %>% split_delimited_columns_in_table(target_colname = "tibble_overlapping_parent_transcript_features", split = ",") %>% dplyr::group_by(tibble_overlapping_parent_transcript_features) %>% dplyr::summarise(n())
tibble_PSIsigma_exon_ontology_biomart_kinase_only <- tibble_PSIsigma_exon_ontology_biomart[tibble_PSIsigma_exon_ontology_biomart$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::group_by(matched_gene_names) %>% dplyr::summarise("any_mobidblite" = mobidblite %>% is.na %>% all == FALSE, "any_seg" = mobidblite %>% is.na %>% all == FALSE, "any_interpro" = interpro %in% tibble_non_family_interpro_entries$Accession %>% any)


tibble_PSIsigma_exon_ontology_biomart[tibble_PSIsigma_exon_ontology_biomart$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::distinct(event_region_coords, diff_exon_coords, Name) %>% dplyr::group_by(Name) %>% dplyr::summarise(n())


tibble_PSIsigma_exon_ontology_PTMs_kinase_only <- tibble_PSIsigma_exon_ontology_PTMs[tibble_PSIsigma_exon_ontology_PTMs$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::group_by(PTM_type) %>% dplyr::summarise(n())

tibble_RNAi_RSA_results <- read.delim(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/MSC.to.OB_kinase.siRNA.screen/analysis_RSA/results/R_processing/RSA_results_summary.txt", header = TRUE, row.names = NULL, stringsAsFactors = FALSE, sep = "\t") %>% as_tibble

# match the RNAi dataset to the kinases identified as differentially spliced
tibble_RNAi_results_diffspliced <- tibble_RNAi_RSA_results[tibble_RNAi_RSA_results$ensembl_gene_id %in% vector_all_kinase_ENSG, ] %>% dplyr::mutate("avg_bothscreens" = (`avg_screen_1` + `avg_screen_2`)/2)

# PVALUE vs. expression PLOT
# plot the negative regulators
ggplot_rnai_negregs <- ggplot(data = tibble_RNAi_results_diffspliced, aes(x = `avg_bothscreens`, y = -`logP_negregs_both.screens`, ggplotlylabel = Gene, colour = (logP_negregs_screen.1 < log10(0.05) | logP_negregs_screen.2 < log10(0.05)), shape = (logP_negregs_screen.1 < log10(0.05) & logP_negregs_screen.2 < log10(0.05)), alpha = (logP_negregs_screen.1 < log10(0.05) & logP_negregs_screen.2 < log10(0.05)))) +
  geom_point() +
  scale_colour_manual(name = "anysig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c("red", "grey75")) +
  scale_shape_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(16, 1)) +
  scale_alpha_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(1, 0.33)) +
  ggtitle("negregs") +
  # scale_x_continuous(breaks = seq(0.6, 1.8, 0.2), limits = c(0.6, 1.8)) +
  xlab("Knockdown fold change in ALP") +
  xlim(c(0.75, 1.75)) +
  ylab("-log10P") +
  ylim(c(0, 4.5)) +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"), panel.grid.major = element_blank(), panel.grid.minor = element_blank())

ggplot_rnai_negregs + 
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 3.5, units = "cm") +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 3.5, units = "cm")

ggplotly(ggplot_rnai_negregs, tooltip = "ggplotlylabel") %>% htmlwidgets::saveWidget(widget = ., file = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.html", sep = ""), selfcontained = FALSE)

# plot the positive regulators
ggplot_rnai_posregs <- ggplot(data = tibble_RNAi_results_diffspliced, aes(x = `avg_bothscreens`, y = -`logP_posregs_both.screens`, ggplotlylabel = Gene, colour = (logP_posregs_screen.1 < log10(0.05) | logP_posregs_screen.2 < log10(0.05)), shape = (logP_posregs_screen.1 < log10(0.05) & logP_posregs_screen.2 < log10(0.05)), alpha = (logP_posregs_screen.1 < log10(0.05) & logP_posregs_screen.2 < log10(0.05)))) +
  geom_point() +
  scale_colour_manual(name = "anysig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c("blue", "grey75")) +
  scale_shape_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(16, 1)) +
  scale_alpha_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(1, 0.33)) +
  ggtitle("posregs") +
  # scale_x_continuous(breaks = seq(0.7, 1.7, 0.3), limits = c(0.7, 1.7)) +
  xlab("Knockdown fold change in ALP") +
  xlim(c(0.75, 1.75)) +
  ylab("-log10P") +
  ylim(c(0, 4.5)) +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"), panel.grid.major = element_blank(), panel.grid.minor = element_blank())

ggplot_rnai_posregs +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 3.5, units = "cm") +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 3.5, units = "cm")

ggplotly(ggplot_rnai_posregs, tooltip = "ggplotlylabel") %>% htmlwidgets::saveWidget(widget = ., file = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.html", sep = ""), selfcontained = FALSE)

options(mc.cores = 144)

# permtest for negregs significance
permtest <- future_map(.x = 1:100000, .f = function(a1) {
  
  set.seed(a1)
  
  tibble_RNAi_RSA_results[sample(1:nrow(tibble_RNAi_RSA_results), size = 59), "logP_negregs_both.screens"] %>% unlist %>% 
    return
  
}, .progress = TRUE )

rand_avg <- mean(permtest %>% unlist)
rand_stdev <- sd(permtest %>% unlist)

```

## plot the interpro and PTM results from JUM and PSI-Sigma together 

### interpro

```{r}

tibble_combined_interpro_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_biomart_plots, tibble_PSIsigma_exon_ontology_biomart_plots, by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 15) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_interpro_RNAlevel, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_interpro_RNAlevel$tally %>% max * 1.3)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma, differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 15, units = "cm")

```

### PTMs

```{r}

tibble_combined_PTMs_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_PTMs_plots, tibble_PSIsigma_exon_ontology_PTMs_plots, by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma, differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 14, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 14, units = "cm")

```

## find out why JUM and PSI-Sigma's PTM matching results are different - not necessary anymore!

```{r}

# join the PTM results onto the differential tables
# tibble_JUM_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, by = c("AS_event_ID", "splicemode")) %>% dplyr::distinct(AS_event_ID, splicemode, .keep_all = TRUE)
# tibble_PSIsigma_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, by = c("diff_exon_coords", "splicemode")) %>% dplyr::distinct(diff_exon_coords, splicemode, .keep_all = TRUE)

```

### investigate dbPTM distribution of phosphosities vs. ubsites - not necessary anymore!

```{r}

# plot(density(tibble_dbPTM_allhuman_annotations %>% dplyr::filter(PTM_type == "Phosphorylation") %>% .$modified_residue_position))

# retrieve protein length annotations from ensembl
# tibble_uniprotkb_to_protein_length <- getBM(filters = "uniprot_gn_id", values = tibble_dbPTM_allhuman_annotations$uniprotkb_entry, attributes = "cds_length", mart = ensembl_mart)

```

## Look for coordinate-level overlap between CLIP-Seq sites and differential/constitutive VSRs.

### set match tolerances

```{r}

# size of RBP footprint or splicing enhancer/silencer site
RBP_footprint_start <- 0
RBP_footprint_end <- 0

# window upstream/downstream beyond the VSR to account for exonic SS/SEs
VSR_tolerance_start <- 100
VSR_tolerance_end <- 100

```

### extract chr start end from the VSR coordinates for both JUM and PSI-Sigma

```{r}

tibble_AS.event.IDs_chr_start_end_differential <- tibble(
  "AS_event_ID" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode) %>%
  unique
  
  tibble_AS.event.IDs_chr_start_end_constitutive <- tibble(
  "AS_event_ID" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode) %>%
  unique

tibble_psisigma_differential_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

tibble_psisigma_constitutive_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

```

### Determine overlap

```{r}

plan(list(tweak(multiprocess, workers = 32),
          tweak(multiprocess, workers = 8)))

list_clipseq_tibbles <- list(
  "SRSF2 HITS-CLIP GSE111900" = tibble_peakfile_SRSF2_hits.clip_GSE111900_HEL_p0.01,
  "HNRNPA1 eCLIP ENCODE" = tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_combined_p0.01,
  "HNRNPA2B1 HITS-CLIP GSM1716538" = `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg38_height20`,
  "MBNL1 HITS-CLIP GSE76486" = `tibble_bedfile_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg38`,
  "PRPF4 eCLIP ENCODE" = tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_combined_p0.01,
  "RBM15 eCLIP ENCODE" = tibble_bedfile_RBM15_eclip_ENCODE_HepG2_combined_p0.01,
  "SFPQ eCLIP ENCODE" = tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_combined_p0.01,
  "SUGP2 eCLIP ENCODE" = tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_combined_p0.01,
  "TRA2A eCLIP ENCODE" = tibble_bedfile_TRA2A_eclip_ENCODE_K562_combined_p0.01,
  "SNRPA eCLIP GSM4512295" = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg38_p0.01
) %>% purrr::map(.x = ., .f = ~.x %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {x[which(x == "M")] <- "MT"; return(x)} ))

list_clipseq_tibbles <- purrr::splice(list_FLASHseq_tibbles_hg38, 
                                      list_clipseq_tibbles)


# cross JUM/PSI-sigma diff/const. with each of the CLIP-Seq peakfiles.
list_clipseq_peakfiles_x_jum_psisigma_tibbles <- purrr::cross2(
  .x = list_clipseq_tibbles,
  .y = list(
    dplyr::bind_rows(tibble_AS.event.IDs_chr_start_end_differential, tibble_psisigma_differential_chr_start_end),
    dplyr::bind_rows(tibble_AS.event.IDs_chr_start_end_constitutive, tibble_psisigma_constitutive_chr_start_end)
  )
)

# also cross names for traceability
list_clipseq_peakfiles_x_jum_psisigma_tibbles_names <- purrr::cross2(
  .x = names(list_clipseq_tibbles),
  .y = list(
    "JUM_and_PSIsigma_differential",
    "JUM_and_PSIsigma_constitutive"
  )
)

# calculate overlap
list_overlaps_clipseq_peakfiles_x_jum_psisigma <- furrr::future_map2(
  .x = list_clipseq_peakfiles_x_jum_psisigma_tibbles,
  .y = list_clipseq_peakfiles_x_jum_psisigma_tibbles_names,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_clipseq_peakfiles_x_jum_psisigma_tibbles[[1]]
    # a2 <- list_clipseq_peakfiles_x_jum_psisigma_tibbles_names[[1]]
    ###########
    
    tibble_clipseq_regions <- a1[[1]]
    
    ## loop thru each SF and look for overlap with CLIP-Seq region within a tolerance range
    ## list-ify the SF chr and coords.
    list_query_VSR_coord_array.tree <- a1[[2]][, c("chr", "start", "end")] %>% array_tree
    
    ## parallel loop thru each list-ified SF to find whether there is a match with an entry in the CLIP-Seq data.
    vector_matched_VSR_with_CLIP_seq_logical <- future_map(.x = list_query_VSR_coord_array.tree,
                                                           .f = function(b1) {
                                                             
                                                             # DEBUG ###
                                                             # b1 <- list_query_VSR_coord_array.tree[[1]]
                                                             ###########
                                                             
                                                             any(tibble_clipseq_regions$chr == b1$chr & 
                                                                   (tibble_clipseq_regions$start %>% type.convert) <= ((b1$end %>% type.convert) + VSR_tolerance_end) &
                                                                   (tibble_clipseq_regions$end %>% type.convert) >= ((b1$start %>% type.convert) - VSR_tolerance_start)) %>% return
                                                             
                                                           }, .progress = TRUE, .options = future_options(globals = c("tibble_clipseq_regions", "VSR_tolerance_start", "VSR_tolerance_end")) ) %>% unlist
    
    # filter the original coord table by those that overlapped with clip-seq data.
    tibble_VSRs_with_overlap <- a1[[2]][which(vector_matched_VSR_with_CLIP_seq_logical), ]
    
    # for the VSRs with overlap, extract the clipseq regions that matched
    list_tibble_VSRs_with_overlap_with_matched_clipseq_regions <- purrr::map(
      .x = tibble_VSRs_with_overlap %>% array_tree,
      .f = function(b1) { 
        
        # DEBUG ###
        # b1 <- tibble_VSRs_with_overlap %>% array_tree %>% .[[1]]
        ###########
        
        tibble_clipseq_regions_inside_VSR <- tibble_clipseq_regions[tibble_clipseq_regions$chr == b1$chr & 
                                                                      (tibble_clipseq_regions$start %>% type.convert) <= ((b1$end %>% type.convert) + VSR_tolerance_end) &
                                                                      (tibble_clipseq_regions$end %>% type.convert) >= ((b1$start %>% type.convert) - VSR_tolerance_start), ]
        
        names(tibble_clipseq_regions_inside_VSR) <- paste("clipseq_", names(tibble_clipseq_regions_inside_VSR), sep = "")
        
        # tibblise the matched VSR tibble entry
        tibble_matched_VSR_entry <- b1 %>% as_tibble
        
        names(tibble_matched_VSR_entry) <- paste("VSR_", names(tibble_matched_VSR_entry), sep = "")
        
        # bind cols and return 
        tibble_VSR_entry_matched_to_overlapping_clipseq_entries <- dplyr::bind_cols(tibble_matched_VSR_entry, tibble_clipseq_regions_inside_VSR)
        
        return(tibble_VSR_entry_matched_to_overlapping_clipseq_entries)
        
      } )
    
    # rbind and tibblise
    tibble_VSRs_with_overlap_with_matched_clipseq_regions <- list_tibble_VSRs_with_overlap_with_matched_clipseq_regions %>% rbindlist %>% as_tibble
    
    return(list(tibble_VSRs_with_overlap, tibble_VSRs_with_overlap_with_matched_clipseq_regions) %>% 
             set_names(c(paste(a2[[2]], a2[[1]], "tibble_VSRs_with_overlap", sep = "|"),
                         paste(a2[[2]], a2[[1]], "tibble_VSRs_with_overlap_with_matched_clipseq_regions", sep = "|"))))
    
  }, .progress = TRUE, .options = future_options(globals = c("VSR_tolerance_start", "VSR_tolerance_end")) )

list_overlaps_clipseq_peakfiles_x_jum_psisigma <- list_overlaps_clipseq_peakfiles_x_jum_psisigma %>% purrr::flatten()

save(list_overlaps_clipseq_peakfiles_x_jum_psisigma, file = paste(results_dir, "list_overlaps_clipseq_peakfiles_x_jum_psisigma.Rlist", sep = ""))

```

### Match the VSR coordinates back to the combinedexpr PSI timeseries tables, find the clusters regulated by each SF

```{r}

wide_tibble_consensus_combinedexpr_clusters <- read.delim(file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_wide.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# table join back onto the JUM/PSIsigma combinedexpr tables.
list_JUM_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap$")] %>% purrr::map(~dplyr::semi_join(wide_tibble_consensus_combinedexpr_clusters ,.x %>% dplyr::rename("category" = "splicemode") %>% .[!is.na(.$AS_event_ID), ], by = c("AS_event_ID", "category")))

list_PSIsigma_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap$")] %>% purrr::map(~dplyr::semi_join(wide_tibble_consensus_combinedexpr_clusters, .x %>% dplyr::rename("category" = "splicemode") %>% .[!is.na(.$event_region_coords), ], by = c("event_region_coords", "category")))

# combine the lists of tibbles
list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- purrr::map2(.x = list_JUM_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .y = list_PSIsigma_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .f = ~dplyr::bind_rows(.x, .y))

# do a headcount of the number of targets per cluster
list_JUM_PSIsigma_combined_diff_targets_per_cluster <- purrr::map(.x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .f = ~.x %>% dplyr::group_by(cluster) %>% dplyr::summarise("no_targets_per_cluster" = `id` %>% unique %>% length) %>% dplyr::arrange(desc(no_targets_per_cluster)))

# extract genesets
list_geneset_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq <- list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% purrr::map(~.x$gene %>% unique %>% mixedsort)

```

results of previous chunk:
SRSF1 (DS 2, 3): <NOTHING>
SRSF2 (DE 4) (DS 1, 2, 7): HNRNPA1, HNRNPH1, SRRM2, SRSF1/5
SRSF3 (DS 2): HNRNP2AB1, SNRNP70, SRRM2, SRSF1/2, TRA2B
SRSF5 (DS 1): HNRNPH1, SRRM2, SRSF2
SRSF6 (DS 1, 2, 4, 7): HNRNPA2B1, HNRNPH1, PRPF4B, SFPQ, SRSF1/2/11
SRSF11 (DS 1, 5, 8, 10, 12): CIRBP, HNRNPA2B1, HNRNPH1, RBM6/25/39, SFPQ, SRRM2, SRSF2, U2AF1L4

HNRNPA1 (DE 4) (DS 4): HNRNPA1, HNRNPA2B1, SRSF6, TRA2A/B
HNRNPA2B1 (DE 4) (DS 1, 2, 4, 5): HNRNPA1, HNRNPA2B1, HNRNPDL, HNRNPH1, RBM39, SFPQ, SRSF5/6, TRA2A

MBNL1 (DS 1, 2, 3, 6, 7, 13, 14): MBNL1, SNRNP70, TRA2A

PRPF4 (DE 6): RBM6, SRRM2

RBM15 (DE 6): MBNL1, RBM6

SFPQ (DE 4) (DS 1, 7): HNRNPH1, RBM6, SFPQ, SRRM2, TRA2A/B

TRA2A (DS 1, 3, 4, 9): SFPQ, SNRNP70, SRRM2, SRSF1/2, TRA2A/B

SNRPA (DE 4): HNRNPA1, HNRNPA2B1, SNRNP70, SRSF6, TRA2A/B

NOTE: we will have to consider BOTH cluster AND anti-clusters because we can't make any assumptions about the positive/negative regulation of splicing by splicing factors.

### GO analysis of genes targeted by SF

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

# map GO test
## NOTE: we are going to consider only gene targets that co-clustered with the SFs.
## therefore map alongside the cluster specifications
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms <- future_pmap(
  .l = list(
    "a1" = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")], 
    "a2" = list(
      "JUM_and_PSIsigma_differential|SRSF1 FLASH GSE118265" = c(2, 3, 4, 6),
      "JUM_and_PSIsigma_differential|SRSF2 FLASH GSE118265" = c(4, 2),
      "JUM_and_PSIsigma_differential|SRSF3 FLASH GSE118265" = c(4, 2),
      "JUM_and_PSIsigma_differential|SRSF5 FLASH GSE118265" = c(7, 1),
      "JUM_and_PSIsigma_differential|SRSF6 FLASH GSE118265" = c(1, 2, 4, 7),
      "JUM_and_PSIsigma_differential|SRSF11 FLASH GSE118265" = c(5, 12),
      "JUM_and_PSIsigma_differential|HNRNPA1 eCLIP ENCODE" = c(4, 2),
      "JUM_and_PSIsigma_differential|HNRNPA2B1 HITS-CLIP GSM1716538" = c(4, 2),
      "JUM_and_PSIsigma_differential|MBNL1 HITS-CLIP GSE76486" = c(2, 7, 1, 4),
      "JUM_and_PSIsigma_differential|PRPF4 eCLIP ENCODE" = c(3, 6),
      "JUM_and_PSIsigma_differential|RBM15 eCLIP ENCODE" = c(3, 6),
      "JUM_and_PSIsigma_differential|SFPQ eCLIP ENCODE" = c(4, 2),
      "JUM_and_PSIsigma_differential|SUGP2 eCLIP ENCODE" = c(3, 2, 4, 5, 6, 12, 13, 14),
      "JUM_and_PSIsigma_differential|TRA2A eCLIP ENCODE" = c(1, 4, 2, 7),
      "JUM_and_PSIsigma_differential|SNRPA eCLIP GSM4512295" = c(4, 2)
    ), 
    "a3" = names(list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")])
  ),
  .f = function(a1, a2, a3) {
    
    target_entries <- a1[a1$cluster %in% a2, ]
    
    geneset <- a1[a1$cluster %in% a2, "gene"] %>% unlist %>% unique %>% mixedsort
    
    list_GO_tables <- future_map(.x = c("MF", "BP", "CC"),
               .f = function(b1) {
                 
                 cat(a3, "\n")
                 
                 systemPipeR::GOHyperGAll(catdb = catdb, gocat = b1, sample = geneset, Nannot = 2) %>% GOHyperGAll_benjamini_correction(FDR_cutoff = 1) %>% type_convert %>% as_tibble
                 
               }, .options = future_options(globals = c("systemPipeR::GOHyperGAll", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble"))) %>% set_names(c("MF", "BP", "CC"))
    
    return(list(
      "target_entries" = target_entries,
      "geneset" = geneset,
      "list_GO_tables" = list_GO_tables
    ))
    
  }, .progress = TRUE, .options = future_options(globals = c("systemPipeR::GOHyperGAll", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble"))) %>% 
  set_names(names(list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")]))

# extract the GO term tables and geneset
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$list_GO_tables)
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$geneset)
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$target_entries)

# plot the GO terms into a a cute rectangular heatmap
## rbind the GO enrichmnent tables
long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- purrr::map2(
  .x = list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms,
  .y = names(list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms),
  .f = function(a1, a2) {
    
    a1 %>% 
      purrr::reduce(dplyr::bind_rows) %>%
      add_column("sample" = a2) %>%
      return
    
  } ) %>% purrr::reduce(dplyr::bind_rows)

## filter out samples we don't need
long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms %>% 
  dplyr::mutate_at(.vars = "sample", .funs = function(x) {gsub(x = x, pattern = "^(.*)\\|(.*)\\|(.*)", replacement = "\\2")} ) 

## ggplot
### set the order of sample
vector_clipseq_sample_order_for_ggplot <- long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms$sample %>% unique %>% mixedsort
### set the order of GO terms
vector_clipseq_goterm_order_for_ggplot <- c(
  # BP
  "mRNA splicing, via spliceosome", "histone modification", "focal adhesion assembly", "mitotic cell cycle phase transition",
  # MF
  "chromatin binding", "transcription coregulator activity", "protein kinase regulator activity",
  # CC
  "focal adhesion", "actin cytoskeleton"
  ) %>% rev

ggplot(long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms) +
  geom_tile(aes(x = sample, y = Term, fill = Padj)) +
  facet_wrap(facets = ~Ont, scales = "free", ncol = 1) +
  ggtitle(paste("Heatmap of GO Terms for public CLIP-Seq targets (differential)", sep = "")) +
  scale_x_discrete(breaks = vector_clipseq_sample_order_for_ggplot, labels = vector_clipseq_sample_order_for_ggplot, limits = vector_clipseq_sample_order_for_ggplot, position = "top") +
  scale_y_discrete(breaks = vector_clipseq_goterm_order_for_ggplot, labels = vector_clipseq_goterm_order_for_ggplot, limits = vector_clipseq_goterm_order_for_ggplot) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black", "black"), values = c(0, 0.5, 0.94, 0.95, 1), trans = "reverse") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 0, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_combinedexpr_diff_public_clipseq_GOterms.pdf", sep = ""), device = "pdf", dpi = 600, width = 17, height = 25, units = "cm", limitsize = FALSE) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_combinedexpr_diff_public_clipseq_GOterms.svg", sep = ""), device = "svg", dpi = 600, width = 17, height = 25, units = "cm", limitsize = FALSE)

```

## JUM/PSI-Sigma and Ago2 iCLIP

### determine gene-level overlap between differentially spliced genes and Ago2 iCLIP

```{r}

# JUM
## convert transcript_ids to gene_stable_id
# vector_JUM_gene_stable_ids <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$matched_ref_transcript_names %>% strsplit(split = "\\;") %>% purrr::map(~.x %>% type.convert %>% na.omit) %>% future_map(.f = ~tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$transcript_stable_ID %in% .x), "gene_stable_ID"] %>% unlist, .progress = TRUE) %>% unlist

vector_JUM_gene_names <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique

vector_JUM_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_JUM_gene_names), "gene_stable_ID"] %>% unlist %>% unique


tibble_ago2_iclip_binding_sites_JUM_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_JUM_gene_names |
                                                                                                 `5'UTR` %in% vector_JUM_gene_names |
                                                                                                 `CDS` %in% vector_JUM_gene_names |
                                                                                                 `antisense_gene` %in% vector_JUM_gene_names |
                                                                                                 `lncRNA` %in% vector_JUM_gene_stable_ids)

# PSI-Sigma
## convert transcript_ids to gene_stable_id
vector_PSIsigma_gene_names <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% strsplit(split = "\\,") %>% unlist %>% type.convert %>% unique

vector_PSIsigma_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_PSIsigma_gene_names), "gene_stable_ID"] %>% unlist %>% unique

tibble_ago2_iclip_binding_sites_PSIsigma_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `5'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `CDS` %in% vector_PSIsigma_gene_names |
                                                                                                 `antisense_gene` %in% vector_PSIsigma_gene_names |
                                                                                                 `lncRNA` %in% vector_PSIsigma_gene_stable_ids)

```

### determine if there's any VSR-level overlap between differential regions/exons and Ago2 iCLIP

```{r}

# JUM
## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                      .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                      .f = function(a1, a2) {
                                                                        
                                                                        # DEBUG ###
                                                                        # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                        # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                        ###########
                                                                        
                                                                        # get chromosome
                                                                        current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                        
                                                                        # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                        vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                        
                                                                        # retrieve iCLIP entries based on logical index
                                                                        tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                        
                                                                        return(purrr::splice(a2,
                                                                                             "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                      }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_JUM_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_JUM_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# PSI-Sigma
## create list of vectors of differential positions (genomic coords)
list_of_vectors_PSIsigma_differential_exon_positions <- tibble_PSIsigma_exon_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_PSIsigma <- future_map2(.x = list_of_vectors_PSIsigma_differential_exon_positions,
                                                                           .y = tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree,
                                                                           .f = function(a1, a2) {
                                                                             
                                                                             # DEBUG ###
                                                                             # a1 <- list_of_vectors_PSIsigma_differential_exon_positions[[1]]
                                                                             # a2 <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree %>% .[[1]]
                                                                             ###########
                                                                             
                                                                             # get chromosome
                                                                             current_chr <- gsub(x = a2$diff_exon_coords, pattern = "^([^\\:]+)\\:.*", replacement = "\\1")
                                                                             
                                                                             # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                             vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                             
                                                                             # retrieve iCLIP entries based on logical index
                                                                             tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                             
                                                                             return(purrr::splice(a2,
                                                                                                  "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                           }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned <- list_matched_iCLIP_entries_per_differential_region_PSIsigma %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_PSIsigma_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_PSIsigma_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_PSIsigma_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Draw a consensus SOM which merges JUM and PSI-Sigma together.

### Tally up the number of repeated VSRs per gene.

```{r}

tibble_exon_tally_per_gene_PSIsigma <- tibble_PSIsigma_5x5_som_clustered %>% 
  split_delimited_column_in_table(input_table = ., target_colname = "matched_gene_names", split = ",") %>%
  dplyr::distinct(matched_gene_names, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(event_region_coords, .keep_all = TRUE) %>%
  dplyr::group_by(matched_gene_names) %>% 
  dplyr::summarise("PSIsigma_tally" = n()) %>%
  dplyr::arrange(desc(PSIsigma_tally)) %>%
  dplyr::rename("Gene" = "matched_gene_names")

ggplot(data = tibble_exon_tally_per_gene_PSIsigma %>% na.omit, aes(x = PSIsigma_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("PSI-Sigma tally, diff_exon_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

tibble_AS_event_ID_tally_per_gene_JUM <- tibble_JUM_5x5_som_clustered %>% 
  dplyr::distinct(Gene, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>%
  dplyr::group_by(Gene) %>% 
  dplyr::summarise("JUM_tally" = n()) %>%
  dplyr::arrange(desc(JUM_tally))

ggplot(data = tibble_AS_event_ID_tally_per_gene_JUM %>% na.omit, aes(x = JUM_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("JUM tally, AS_event_ID per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

# merge the two tallies together for co-plotting
tibble_AS_event_ID_tally_per_gene_combined <- dplyr::full_join(tibble_AS_event_ID_tally_per_gene_JUM, tibble_exon_tally_per_gene_PSIsigma, by = "Gene")

tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")][is.na(tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")])] <- 0

# melt into long form for combined ggplot
long_tibble_AS_event_ID_tally_per_gene_combined <- tibble_AS_event_ID_tally_per_gene_combined %>%
  na.omit %>%
  reshape2::melt(id.vars = "Gene", value.name = "tally", variable.name = "tool") %>% as_tibble

long_tibble_AS_event_ID_tally_per_gene_combined[, "tally"] <- long_tibble_AS_event_ID_tally_per_gene_combined$tally %>% as.character

write.table(x = long_tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "long_tibble_VSR_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
write.table(x = tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "wide_tibble_VSR_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# create tally frequency
long_tibble_AS_event_ID_tally_per_gene_combined_tally <- long_tibble_AS_event_ID_tally_per_gene_combined %>% 
  dplyr::group_by(tool, tally) %>% 
  dplyr::summarise("frequency" = n()) %>% 
  # tidyr complete for consistent bar width
  tidyr::complete(tool, tally)

# combined tally plot
ggplot(data = long_tibble_AS_event_ID_tally_per_gene_combined_tally, aes(x = tally, y = frequency, fill = tool)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  geom_text(stat = "identity", aes(label = frequency), position = position_dodge(width = 1), angle = 90, hjust = -0.1) +
  scale_x_discrete(breaks = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character, limits = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character) +
  scale_fill_manual(breaks = c("JUM_tally", "PSIsigma_tally"), labels = c("JUM", "PSI-Sigma"), values = c("purple3", "firebrick4")) +
  ylim(c(0, 900)) +
  ggtitle("Combined tally, AS_event_ID/event_region_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

### preprocessing of tables in preparation for mixing

```{r}

# create unique ID that can be traced.
tibble_PSIsigma_scaled_PSI_timeseries_wide_processed <- tibble_PSIsigma_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("PSIsigma", .$matched_gene_names, .$database_ID, .$event_region_coords, .$diff_exon_coords, .$splicemode, sep = "|")) %>%
  dplyr::select(id, vector_OBseries_timepoints_edited)

tibble_JUM_scaled_PSI_timeseries_wide_processed <- tibble_JUM_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("JUM", .$Gene, .$AS_event_ID, .$sub_junction_start_coor, .$sub_junction_end_coor, .$splicemode, sep = "|")) %>%
  dplyr::select(id, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"))

# join
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- dplyr::bind_rows(tibble_PSIsigma_scaled_PSI_timeseries_wide_processed, tibble_JUM_scaled_PSI_timeseries_wide_processed)

# rescale values
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### Skim off the top and bottom most included exons/LSVs to get biomarkers at each timepoint.

```{r}

# melt into long form
long_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% reshape2::melt(id.vars = "id", variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# subset by timepoint
list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint <- purrr::map(.x = long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint %>% unique,
                                                                               .f = ~long_tibble_JUM_PSIsigma_PSI_timeseries_merged[long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint == .x, ])

# take the items with scaled PSI greater/less than +/-1.
# rbind and tibblise
list_biomarkers_JUM_PSIsigma_per_timepoint <- list(
  "inclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value >= 1)),
  "exclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value <= -1))
) %>% purrr::map(~rbindlist(.x) %>% as_tibble)

# create tally of counts to determine which markers are unique
# splice in unique counts
list_biomarkers_JUM_PSIsigma_per_timepoint <- list_biomarkers_JUM_PSIsigma_per_timepoint %>% 
  purrr::map(~dplyr::left_join(.x, .x %>% dplyr::group_by(id) %>% dplyr::summarise("uniqueness_tally" = n()))) %>%
  purrr::splice(
    "unique_inclusion" = .$inclusion %>% dplyr::filter(uniqueness_tally == 1),
    "unique_exclusion" = .$exclusion %>% dplyr::filter(uniqueness_tally == 1)
  )

# save the list
save(list_biomarkers_JUM_PSIsigma_per_timepoint, file = paste(results_dir, "list_biomarkers_JUM_PSIsigma_per_timepoint.Rlist", sep = ""))

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# remove na
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% add_column("id" = rownames(.)) %>% na.omit %>% .$id, ]

somdata_5_by_5_OBseries <- som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries <- cbind(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, c("id", vector_OBseries_timepoints_edited)], cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of PSI values for JUM and PSI-Sigma")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

options(mc.cores = 32)

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("wide_tibble_JUM_PSIsigma_PSI_timeseries_merged", "dplyr", "som")) ) %>% as.data.frame

wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, "id"] <- paste(1:nrow(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged), wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, sep = "_")

# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 72)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for clustering by PSI\nOB spliceome: JUM and PSI-Sigma", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED LEVELS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combined_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 6) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "item_id" = "NA", 
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", 
             "matched_strand" = "NA", .after = "S6")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "matched_strand"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

cat("\nnumber of unique items originally: ", gsub(x = wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
vector_items_chucked_out <- setdiff(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id %>% unique, wide_tibble_consensus_clusters_MQ_ratios$id %>% unique)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("method", "gene", "item_id", "category", "sub_junction_start", "sub_junction_end", "matched_strand", "cluster", "id"), variable.name = "timepoint", value.name = "scaled_PSI") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_PSI" = mean(scaled_PSI))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_PSI, group = paste(id)), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_PSI, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI\n",
                "JUM and PSI-Sigma\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled MQ ratios") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "table_JUM_PSisigma_consensus_combined_GOterms.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

## ggplot
### set the order of sample
vector_combined_JUM_PSIsigma_cluster_order_for_ggplot <- c(1, 2, 3, 4, 5, 6, 7, 10, 11, 14, 15) %>% as.character
### set the order of GO terms
vector_combined_JUM_PSIsigma_goterm_order_for_ggplot <- c(
  # BP
  "cell cycle", "mRNA splicing, via spliceosome", "histone modification", "post-Golgi vesicle-mediated transport", "regulation of autophagy of mitochondrion",
  # MF
  "extracellular matrix structural constituent", "cell adhesion molecule binding", "transcription factor binding", "transcription coregulator activity", "protein kinase activity", "GTPase binding",
  # CC
  "focal adhesion", "actin cytoskeleton", "cell cortex", "microtubule cytoskeleton"
  ) %>% rev

ggplot(tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma) +
  geom_tile(aes(x = cluster, y = Term, fill = Phyper, color = (Padj <= 0.05) %>% as.character), size = 0.5) +
  # facet_wrap(facets = ~Ont, scales = "free", ncol = 1) +
  ggtitle(paste("Heatmap of GO Terms for JUM/PSI-Sigma combined consensus clusters(differential)", sep = "")) +
  scale_x_discrete(breaks = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, labels = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, limits = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, position = "top") +
  scale_y_discrete(breaks = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot, labels = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot, limits = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black", "black"), values = c(0, 0.5, 0.94, 0.96, 1), trans = "reverse") + 
  scale_colour_manual(limits = c("TRUE", "FALSE"), breaks = c("TRUE", "FALSE"), labels = c("Padj <= 0.05", "Padj > 0.05"), values = c("green", "white")) + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 0, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_consensus_combined_GOterms.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 8, units = "cm", limitsize = FALSE) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_consensus_combined_GOterms.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 8, units = "cm", limitsize = FALSE)

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(.x = list_of_genesets_by_cluster, .y = names(list_of_genesets_by_cluster), .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column("cluster" = .y), .progress = TRUE)

# tibble of everything PFAM results
tibble_consensus.SOM_family.enrichment_clusterwise <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

# save PFAM family tables (all)
write.table(x = tibble_consensus.SOM_family.enrichment_clusterwise, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combined_JUM_PSIsigma_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Compare GO terms from DEGs with GO terms from DSGs

### generate GO enrichment table for DSGs combined and table join the tibbles

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

tibble_RSEM_edgeR_DEGs_all_GO

tibble_JUM_PSISigma_DSGs_all_GO <- c("MF", "BP", "CC") %>% purrr::map(~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique, Nannot = 2)) %>% rbindlist %>% as_tibble

tibble_RSEM_edgeR_DEGs_all_GO_2 <- tibble_RSEM_edgeR_DEGs_all_GO %>% dplyr::rename("SampleKeys_DEG" = "SampleKeys", "Phyper_DEG" = "Phyper", "Padj_DEG" = "Padj", "SampleMatch_DEG" = "SampleMatch")
tibble_JUM_PSISigma_DSGs_all_GO_2 <- tibble_JUM_PSISigma_DSGs_all_GO %>% dplyr::rename("SampleKeys_DSG" = "SampleKeys", "Phyper_DSG" = "Phyper", "Padj_DSG" = "Padj", "SampleMatch_DSG" = "SampleMatch")

tibble_hyperGO_DSGs_DEGs_joined <- dplyr::inner_join(tibble_RSEM_edgeR_DEGs_all_GO_2, tibble_JUM_PSISigma_DSGs_all_GO_2)

tibble_hyperGO_DSGs_DEGs_joined_filtered <- tibble_hyperGO_DSGs_DEGs_joined %>% dplyr::filter(Phyper_DEG <= 0.05 | Phyper_DSG <= 0.05)

tibble_hyperGO_DSGs_DEGs_joined_filtered <- tibble_hyperGO_DSGs_DEGs_joined_filtered[order(purrr::map2(.x = tibble_hyperGO_DSGs_DEGs_joined_filtered$Padj_DEG, .y = tibble_hyperGO_DSGs_DEGs_joined_filtered$Padj_DSG, .f = ~sqrt(.x * .y)) %>% unlist %>% type.convert), ]

```

## Consensus SOM: Expression co-clustering with JUM and PSI-Sigma

### extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

options(mc.cores = 32)

# reorder the columns to make them chronological
logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_ud_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

# subset CPM table by biological role
## import mapping table
tibble_ENSG_to_GOterm_and_biotype_mapping <- read.delim(file = paste(reference_data_dir, "table_ENSG_to_GOterm_and_biotype_mapping.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE) %>% as_tibble %>%
  setNames(nm = c("ensembl_gene_id", "go_term_name", "transcript_biotype"))

  # RBPs
column_RBP_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "RNA binding" | tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "lncRNA", "ensembl_gene_id"]

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "snRNA", "ensembl_gene_id"]

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "protein_coding" & tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "matched_gene_names"

# add id column and get rid of the rest
logCPM_OBseries_subset <- logCPM_OBseries_subset %>% 
  add_column("id" = paste(.$matched_gene_names, .$splicemode, .$diff_exon_coords, sep = "|")) %>%
  .[, c("id", vector_OBseries_timepoints_edited)]

# combine logCPM and PSI values
tibble_combinedexpr_logCPM_PSI_unscaled <- dplyr::bind_rows(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged, logCPM_OBseries_subset)

tibble_combinedexpr_logCPM_PSI_scaled <- tibble_combinedexpr_logCPM_PSI_unscaled

# scale values
tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] <- tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(tibble_combinedexpr_logCPM_PSI_scaled %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_combinedexpr_logCPM_PSI_scaled", "dplyr", "genescale", "som")) ) %>% as.data.frame

# use "id" column as rownames
tibble_combinedexpr_logCPM_PSI_scaled[, "id"] <- paste(1:nrow(tibble_combinedexpr_logCPM_PSI_scaled), tibble_combinedexpr_logCPM_PSI_scaled$id, sep = "_")

rownames(wide_table_som_sweep_clusters) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 64)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_combinedexpr_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combinedexpr_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_consensus_matrix_reordered, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for co-clustering by PSI and logCPM\nJUM and PSI-Sigma + RSEM/EdgeR", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_combinedexpr_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_combinedexpr_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED MQ RATIOS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combinedexpr_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, tibble_combinedexpr_logCPM_PSI_scaled %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

cat("\nnumber of unique items originally: ", tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
tibble_items_chucked_out <- dplyr::anti_join(tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% tibble::enframe(name = NULL, value = "id"),
                                             wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% tibble::enframe(name = NULL, value = "id"), by = "id")

# write the items that got chucked out
write.table(x = tibble_items_chucked_out, file = paste(results_dir, "consensus_combinedexpr_items_chucked_out.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# remove TSS from PSI-Sigma ids
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "TSS\\|", replacement = "")
# i fucked up the delimiting for expression
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "_ENSG", replacement = "\\|ENSG")

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 10) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "database_ID" = "NA", 
             "event_region_coords" = "NA", 
             "diff_exon_coords" = "NA", 
             "AS_event_ID" = "NA",
             "ENSG_ID" = "NA",
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", .after = "S10")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "AS_event_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "database_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "event_region_coords"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "diff_exon_coords"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "ENSG_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6, -S7, -S8, -S9, -S10) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("id", "method", "gene", "database_ID", "event_region_coords", "diff_exon_coords", "AS_event_ID", "ENSG_ID", "category", "sub_junction_start", "sub_junction_end", "cluster"), variable.name = "timepoint", value.name = "scaled_level") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_level" = mean(scaled_level))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_level, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_level, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI and expression logCPM\n",
                "JUM, PSI-Sigma, EdgeR/RSEM\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled PSI or logCPM") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster

#### preparation of separate data frames containing DIFFSPLICED gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster_diffspliced <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x[.x$method == "JUM" | .x$method == "PSIsigma", ] %>% .$gene %>% strsplit(split = ",") %>% unlist %>% unique)

# take gene set of differntially expressed genes
list_of_genesets_by_cluster_DEG <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x[.x$method == "RNASeq", ] %>% .$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

##### differentially spliced geneset

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster_diffspliced, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster_diffspliced %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combinedexpr_diffspliced.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### differentially expressed geneset

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster_DEG, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster_DEG %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         # DEBUG ###
                                                                         # a1 <- list_of_combinations_of_genesets_and_GOterms[[28]]
                                                                         # a2 <- list_of_combinations_of_genesets_and_GOterms_names[[28]]
                                                                         ###########
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combinedexpr_DEGs.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

#### Family enrichment of each SOM cluster

##### for diffspliced geneset

```{r}

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(
  .x = list_of_genesets_by_cluster_diffspliced, 
  .y = names(list_of_genesets_by_cluster_diffspliced), 
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_of_genesets_by_cluster_diffspliced[[1]]
    # a2 <- names(list_of_genesets_by_cluster_diffspliced) %>% .[[1]]
    ###########
    
    raw_enrichment_table <- bc3net::enrichment(genes = a1, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction(FDR_cutoff = 1)
    
    raw_enrichment_table %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], a1) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column(cluster = paste(a2)) %>% return 
    
  }, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_pfam_gene_family_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# rbind and write table
tibble_consensus_combinedexpr_PFAM_topinf <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus_combinedexpr_PFAM_topinf, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combinedexpr_diffspliced_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### for DEG geneset

```{r}

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(
  .x = list_of_genesets_by_cluster_diffspliced, 
  .y = names(list_of_genesets_by_cluster_diffspliced), 
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_of_genesets_by_cluster_diffspliced[[1]]
    # a2 <- names(list_of_genesets_by_cluster_diffspliced) %>% .[[1]]
    ###########
    
    raw_enrichment_table <- bc3net::enrichment(genes = a1, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction(FDR_cutoff = 1)
    
    raw_enrichment_table %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], a1) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column(cluster = paste(a2)) %>% return 
    
  }, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_pfam_gene_family_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# rbind and write table
tibble_consensus_combinedexpr_PFAM_topinf <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus_combinedexpr_PFAM_topinf, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combinedexpr_DEGs_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene - DEPRECATED

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
# 
# list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- future_map(.x = list_of_genesets_by_cluster, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_RBP_target_gene_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))
# 
# # filter gene ontology tables for top hits
# list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))
# 
# # add cluster number into each tibble and combine into single tibble
# tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble
# 
# # reorder cluster as factor
# tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits[, "cluster"] <- factor(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster, levels = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster %>% unique %>% mixedsort)
# 
# # plot RBP enrichment per cluster
# ggplot(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits %>% dplyr::arrange(pval), aes(x = reorder(TermID, pval), y = -log10(pval), size = (padj < 0.05) %>% as.character)) +
#   geom_col(aes(fill = genes), colour = "black") +
#   scale_fill_distiller(name = "Number of genes targeted by RBP", type = "seq", palette = "Spectral", direction = -1, aesthetics = "fill", na.value = "yellow") +
#   scale_size_discrete(name = "FDR", breaks = c("TRUE", "FALSE"), limits = c("TRUE", "FALSE"), labels = c("< 0.05", "> 0.05"), range = c(0.1, 0)) +
#   geom_hline(yintercept = -log10(0.05), lty = 2, col = "red") +
#   facet_wrap(~cluster, scales = "free") +
#   ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series\nJUM, PSI-Sigma, RSEM/EdgeR", sep = "")) +
#   scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) +
#   xlab("Upstream RBP") +
#   ylab(expression(log["10"](p))) +
#   # coord_cartesian(ylim = c(0, 20)) +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
#  ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 20, units = "cm") +
#  ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 20, units = "cm")
# 
# write.table(x = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, file = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# JUM, PSI-Sigma and proteome/phosphoproteome.

## co-clustering of expr and phospho/proteome by MSC, 6h and 1d.

We will not use consensus clustering here. Instead, we will be using plain old SOMs. This is because we only have 3 timepoints to work with.

### merge all 4 datasets.

```{r}

# combine into a tibble
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d <- dplyr::bind_rows(
  tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only %>% 
    dplyr::mutate("id" = paste("JUM", `Gene`, `AS_event_ID`, `splicemode`, `sub_junction_start_coor`, `sub_junction_end_coor`, sep = "|")) %>%
    .[, c("id", "MSC", "6h", "1d")],
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_ud.6h.1d_only %>%
    dplyr::mutate("id" = paste("PSISigma", `matched_gene_names`, `database_ID`, `splicemode`, `event_region_coords`, `diff_exon_coords`, sep = "|")) %>%
    .[, c("id", "MSC", "6h", "1d")],
  # protein_groups
  list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d$con_sp.hsa.canonical.isoforms$protein_groups %>%
    dplyr::mutate("id" = paste("protein_groups", `Gene.names`, `Protein.IDs`, sep = "|")) %>% 
    .[, c("id", "MSC", "6h", "1d")],
  # phosphosites
  list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d$con_sp.hsa.canonical.isoforms$phosphosites %>%
    dplyr::mutate("id" = paste("phosphosites|", `Gene.names`, "|", `Protein`, "|Position.in.peptide", `Position.in.peptide`, sep = "")) %>% 
    .[, c("id", "MSC", "6h", "1d")],
)

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

set.seed(som_seed_number)

OB_xdim <- 4
OB_ydim <- 3

number_of_som_clusters <- OB_xdim * OB_ydim

tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d_scaled <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d

# rescale values
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% genescale(m = ., axis = 1, method = "Z")

# remove na
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% add_column("id" = rownames(.)) %>% na.omit %>% .$id, ]

somdata_5_by_5_OBseries <- som(tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_tibble_of_final_SOM_summary_5_by_5_OBseries <- cbind(tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("id", c("MSC", "6h", "1d"))], cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_tibble_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap( ~ cluster) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "\nSOM of PSI (JUM/PSI-Sigma), expr (MQ protein_groups), phosphosites")) +
  scale_x_discrete(limits = c("MSC", "6h", "1d"), labels = c("MSC", "6h", "1d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

write.table(x = wide_tibble_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```
#### GO analysis per cluster

##### catdb

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

##### execute GO analysis

```{r}

# we can look at either what the RNA targets are OR what the proteins/phosphosites are.

# group_split the wide SOM tibble by cluster
list_final_SOM_summary_5_by_5_OBseries <- wide_tibble_of_final_SOM_summary_5_by_5_OBseries %>%
  dplyr::group_split(cluster) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$cluster %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

# loop thru each cluster x targets/proteins x GO category
# note: this purrr returns nothing.
tibble_SOM_combined_PSI_phospho_proteome_GOterms_per_cluster <- furrr::future_map2(
  .x = list_final_SOM_summary_5_by_5_OBseries,
  .y = names(list_final_SOM_summary_5_by_5_OBseries),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_final_SOM_summary_5_by_5_OBseries[[1]]
    ###########
    
    # extract genesets
    list_genesets <- list(
      "JUM_PSISigma" = a1[grep(x = a1$id, pattern = "JUM|PSISigma"), ] %>% gsub(x = .$id, pattern = "^([^\\|]+)\\|([^\\|]+).*", replacement = "\\2") %>% unique %>% .[. != "NA"],
      "protein_groups_phosphosites" = a1[grep(x = a1$id, pattern = "protein_groups|phosphosites"), ] %>% gsub(x = .$id, pattern = "^([^\\|]+)\\|([^\\|]+).*", replacement = "\\2") %>% unique %>% .[. != "NA"]
    )
    
    furrr::future_map2(
      .x = list_genesets,
      .y = names(list_genesets),
      .f = function(b1, b2) {
        
        furrr::future_map(
          .x = c("BP", "MF", "CC"),
          .f = function(c1) {
            
            GOHyperGAll(catdb = catdb, gocat = c1, Nannot = 2, sample = b1) %>% GOHyperGAll_benjamini_correction %>% return
            
          } ) %>% rbindlist %>% add_column("data_origin" = b2) %>% return
        
      } ) %>% rbindlist %>% add_column("cluster" = a2) %>% return
    
  }, .progress = TRUE) %>% rbindlist %>% as_tibble

write.table(x = tibble_SOM_combined_PSI_phospho_proteome_GOterms_per_cluster, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_wide_GOterms_per_cluster.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## JUM: Filter the junction/exon ontology by validated junc.exons
### Match the validated JUM junction identifiers to the junction ID

```{r}

# generate mapping of final_identifiers to junction_ID
UNION_junc_coor_table_with_junction_identifier <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID"), check.names = FALSE) %>% 
  as_tibble %>%
  dplyr::mutate("junction_identifier" = paste(chr, ":", start, "-", end, ":", strand, sep = "") %>% gsub(pattern = "(.*)0$", replacement = "\\1*"))

tibble_JUM_valid_junc.exons_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>%
                                                               dplyr::rename("final_identifier" = "Leading.razor.protein") %>% 
                                                               dplyr::mutate("junction_identifier" = gsub(x = final_identifier, pattern = "JUM_.*junction_", replacement = "")),
                                                             UNION_junc_coor_table_with_junction_identifier,
                                                             by = "junction_identifier")



```

### calculate statistics

loop thru all the junction ontology AS_event_IDs, return the number of contributing junctions that were validated in the proteome.

```{r}

list_number_of_contributing_junctions_validated <- tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique %>% strsplit(split = ",") %>% 
  purrr::map(.f = ~purrr::map(.x = .x, .f = ~any(.x == tibble_JUM_valid_junc.exons_with_junc_ID$junction_ID %>% unique %>% na.omit))) %>% set_names(tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique) %>%
  purrr::keep(.p = ~any(.x == TRUE)) %>%
  purrr::map(.f = ~which(.x == TRUE) %>% length)

```

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_JUM_junction_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_JUM_junction_ontology_supp_info,
                                                                                names(list_number_of_contributing_junctions_validated) %>% tibble::enframe(value = "contributing_junctions"), 
                                                                                by = "contributing_junctions")

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# JUM ###
tibble_JUM_junction_ontology_transcripts_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_transcripts, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_biomart_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_biomart, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_PTMs_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")

```

#### stats summary of JUM junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_JUM_junction_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(AS_event_ID) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per AS_event_ID
tibble_interpro_id_tally_per_ASeventID <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(Gene %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched AS_event_ID mapping
tibble_interpro_ID_to_matched_ASeventID_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("AS_event_IDs" = paste(AS_event_ID %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "AS_event_IDs"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_ASeventID_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of JUM VSRs")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique VSRs with any sort of protein-level annotation: ", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length, " (", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length *100/length(tibble_JUM_junction_ontology_transcripts$AS_event_ID %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique VSRs overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique VSRs overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_filtered_by_proteome_JUM_tally <- tibble_JUM_junction_ontology_PTMs_filtered %>% 
  dplyr::distinct(AS_event_ID, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_filtered_by_proteome_JUM_tally, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nJUM")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_filtered_by_proteome_JUM_tally$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## PSI-Sigma: Filter the junction/exon ontology by validated diff_exon_coords

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_supp_info,
                                                                                tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>% 
                                                                                  dplyr::mutate("event_region_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\1"),
                                                                                                "diff_exon_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\2")), 
                                                                                by = c("event_region_coords", "diff_exon_coords"))

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_biomart_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_biomart, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")
tibble_PSIsigma_exon_ontology_PTMs_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")

```

#### stats summary of PSI-Sigma junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_PSIsigma_exon_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(diff_exon_coords) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per diff_exon_coords
tibble_interpro_id_tally_per_diff_exon_coords <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(matched_gene_names %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched diff_exon_coords mapping
tibble_interpro_ID_to_matched_diff_exon_coords_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("diff_exon_coords" = paste(diff_exon_coords %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "diff_exon_coords"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_diff_exon_coords_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of PSI-Sigma exons")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique exons with any sort of protein-level annotation: ", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length, " (", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length *100/length(tibble_PSIsigma_exon_ontology_transcripts$diff_exon_coords %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique exons overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique exons overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_tally_filtered_by_proteome_PSIsigma <- tibble_PSIsigma_exon_ontology_PTMs_filtered %>% 
  dplyr::distinct(diff_exon_coords, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_tally_filtered_by_proteome_PSIsigma, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nPSI-Sigma")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_tally_filtered_by_proteome_PSIsigma$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## Combined plot of interpro/PTM filtered by proteome evidence

```{r}

### interpro

tibble_combined_interpro_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_interpro_id_tally_per_ASeventID %>% dplyr::rename("tally_JUM" = "tally", "genes_JUM" = "genes"), 
                                                                          tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::rename("tally_PSIsigma" = "tally", "genes_PSIsigma" = "genes"), 
                                                                          by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 10) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_interpro_RNAlevel_filtered_by_proteome, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_interpro_RNAlevel_filtered_by_proteome$tally %>% max * 1.2)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

### PTMs
tibble_combined_PTMs_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_PTM_filtered_by_proteome_JUM_tally %>% dplyr::rename("tally_JUM" = "tally"), 
                                                                       tibble_PTM_tally_filtered_by_proteome_PSIsigma %>% dplyr::rename("tally_PSIsigma" = "tally"), 
                                                                       by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel_filtered_by_proteome, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1, size = 3) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel_filtered_by_proteome$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 10, units = "cm")

```

## Gene ontology analysis of splicing-removed PTMs

```{r}

list_gohyper_tibbles_splicing_removed_PTMs <- c("MF", "BP", "CC") %>% purrr::map(~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = c(tibble_JUM_junction_ontology_PTMs_filtered$Gene %>% unique %>% mixedsort, tibble_PSIsigma_exon_ontology_PTMs_filtered$matched_gene_names %>% unique %>% mixedsort) %>% strsplit(split = ",") %>% unlist)) %>% set_names(c("MF", "BP", "CC"))

```

## filter the valid phosphosites by differential CDS positions.

### JUM

```{r}

# add junction ID onto the phosphosites table
tibble_JUM_valid_phosphosites_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_valid_phosphosites %>% 
                                                                 dplyr::mutate("junction_identifier" = gsub(x = `final_identifier`, pattern = "JUM_.*_junction_", replacement = "")),
                                                                        UNION_junc_coor_table_with_junction_identifier[, c("junction_identifier", "junction_ID")],
                                                               by = "junction_identifier")

# loop thru each junction ID for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_JUM_valid_phosphosites_with_junc_ID$junction_ID,
  .y = tibble_JUM_valid_phosphosites_with_junc_ID$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    subset_junction_ontology_supp_info_by_identifier <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[grep(x = tibble_JUM_junction_ontology_supp_info_filtered_by_proteome$contributing_junctions, pattern = a1), ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_junction_ontology_supp_info_by_identifier$vector_genomic_coords_of_all_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_JUM_valid_phosphosites_with_overlap <- tibble_JUM_valid_phosphosites_with_junc_ID %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_JUM <- tibble_JUM_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_JUM, paste(results_dir, "tibble_validated_phosphosites_JUM.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_JUM$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in JUM AS region")

```

### PSI-Sigma

```{r}

# loop thru each identifier for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_2020.PO4_valid_phosphosites$final_identifier,
  .y = tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- tibble_2020.PO4_valid_phosphosites$final_identifier %>% .[[781]]
    # a2 <- tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ",") %>% .[[781]]
    ###########
    
    # extract the VSR identifier and the alternative exon identifiers by strsplit
    VSR_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\1")
    alternative_exon_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\2")
    
    subset_exon_ontology_supp_info_by_identifier <-
      tibble_PSIsigma_exon_ontology_supp_info[tibble_PSIsigma_exon_ontology_supp_info$event_region_coords == VSR_identifier & 
                                                tibble_PSIsigma_exon_ontology_supp_info$diff_exon_coords == alternative_exon_identifier, ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_exon_ontology_supp_info_by_identifier$list_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_PSIsigma_valid_phosphosites_with_overlap <- tibble_2020.PO4_valid_phosphosites %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_PSIsigma <- tibble_PSIsigma_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_PSIsigma, paste(results_dir, "tibble_validated_phosphosites_PSIsigma.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_PSIsigma$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in PSI-Sigma AS region")

```

## Calculate bootstrap P values of the JUM/PSI-Sigma:

- Transcript regions
- Interpro domains (ALL + proteome filtered)
- Biomart regions esp. LCR (ALL + proteome filtered)
- PTM overlap  (ALL + proteome filtered)

NOTE: For all the proteome-filtered, MUST walk along the **CDS**.

### Meaning we need to cast onto the genome, convert to Granges then convert to transcript-relative topology:

- Biomart reference regions (easiest to do)
- Biomart regions, incl. interpro domains, LCR.
- Each interpro domain
- dbPTM sites (which already includes phosphositeplus)

### set environment and GTF

```{r}

library(regioneR)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg38)

tibble_ref_gtf_original <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("chr", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
tibble_PTM_combined <- tibble_dbPTM_allhuman_annotations
```

### Reference preprocessing: define and map topologies, cast reference regions onto exon-relative coords.

1. define exonic and CDS relative topology mapping
2. create the effective exome/CDSome
3. convert transcript regions, biomart regions and PTM sites to exon/CDS-relative coords.

NOTE: biomart regions and PTM sites need to be pre-cast onto the genome before converting to CDS-relative coords.

#### construction of the effective transcriptome

```{r}

plan(list(tweak(multisession, workers = 8),
          tweak(multisession, workers = 4))
)

# extract exonic entries only
tibble_transcriptomic_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "transcript", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_transcriptomic_GTF_entries_unique <- tibble_transcriptomic_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutely necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_transcriptomic_GTF_entries_unique <- granges_transcriptomic_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_transcriptomic_GTF_entries <- tibble_transcriptomic_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_transcriptomic_GTF_entries) <- list_transcriptomic_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_transcriptomic_GTF_entries <- list_transcriptomic_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO TRANSCRIPT-RELATIVE TOPOLOGY MAPPING
list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping <- future_map(.x = list_transcriptomic_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_exonic_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_transcriptome_relative_end <- vec_sum_of_widths
                                                            vec_transcriptome_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("transcriptome_relative_start" = vec_transcriptome_relative_start,
                                                                                              "transcriptome_relative_end" = vec_transcriptome_relative_end)
                                                            
                                                          }, .progress = TRUE )

# create granges of the effective exome
## first get start and end based on the exon relative coords
tibble_effective_transcriptome <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$transcriptome_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_transcriptome <- toGRanges(tibble_effective_transcriptome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

```

#### construction of the effective exome AND transcript region conversion

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# extract exonic entries only
tibble_exonic_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_exonic_GTF_entries_unique <- tibble_exonic_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutely necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_exonic_GTF_entries_unique <- granges_exonic_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_exonic_GTF_entries <- tibble_exonic_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_exonic_GTF_entries) <- list_exonic_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_exonic_GTF_entries <- list_exonic_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO TRANSCRIPT-RELATIVE TOPOLOGY MAPPING
list_exonic_GTF_entries_genome_to_exon_relative_mapping <- future_map(.x = list_exonic_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_exonic_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_transcript_relative_end <- vec_sum_of_widths
                                                            vec_transcript_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("transcript_relative_start" = vec_transcript_relative_start,
                                                                                              "transcript_relative_end" = vec_transcript_relative_end)
                                                            
                                                          }, .progress = TRUE )

# create granges of the effective exome
## first get start and end based on the exon relative coords
tibble_effective_exome <- list_exonic_GTF_entries_genome_to_exon_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$transcript_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_exome <- toGRanges(tibble_effective_exome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

# move non-exonic entries over to exome-relative coords.
## we will choose everything except for gene, transcript and selenocysteine because they span across multiple exons and hence will break the matching algorithm.
tibble_non_exonic_GTF_entries <- dplyr::bind_rows(
  tibble_ref_gtf_original[tibble_ref_gtf_original$type %in% c("CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr"), ],
  tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon" & tibble_ref_gtf_original$transcript_biotype %in% c("protein_coding", "lncRNA", "miRNA"), ] )
## group-split the non-exonic entries by chromosome so we can map2 over both.
list_non_exonic_GTF_entries <- purrr::map(.x = names(list_exonic_GTF_entries_genome_to_exon_relative_mapping),
                                          .f = ~tibble_non_exonic_GTF_entries[tibble_non_exonic_GTF_entries$chr == .x, ])

## map2 over exonic and non-exonic GTF entries.
list_non_exonic_GTF_entries_exon_relative_coords <- future_map2(.x = list_exonic_GTF_entries_genome_to_exon_relative_mapping,
                                                                .y = list_non_exonic_GTF_entries,
                                                                .f = function(a1, a2) {
                                                                  
                                                                  # DEBUG ###
                                                                  # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
                                                                  # a2 <- list_non_exonic_GTF_entries[[1]]
                                                                  ###########
                                                                  
                                                                  # list-ify the non-exonic entries
                                                                  list_non_exonic_subset <- a2 %>% array_tree
                                                                  # loop thru each element, find overlapping exonic interval, subtract 
                                                                  list_non_exonic_subset_transcript_relative_coords <- future_map(
                                                                    .x = list_non_exonic_subset,
                                                                    .f = function(b1) {
                                                                      
                                                                      # DEBUG ###
                                                                      # b1 <- list_non_exonic_subset[[1]]
                                                                      ###########
                                                                      
                                                                      tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
                                                                      
                                                                      # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
                                                                      shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
                                                                      transcript_relative_start <- (b1$start %>% type.convert) - shift
                                                                      transcript_relative_end <- (b1$end %>% type.convert) - shift
                                                                      
                                                                      output_tibble <- splice(
                                                                        b1,
                                                                        "transcript_relative_start" = transcript_relative_start %>% list,
                                                                        "transcript_relative_end" = transcript_relative_end %>% list
                                                                      ) %>% as_tibble
                                                                      
                                                                      return(output_tibble)
                                                                      
                                                                    }, .progress = TRUE, .options = future_options(globals = c("a1")) )
                                                                  
                                                                }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_non_exonic_GTF_entries_exon_relative_coords <- list_non_exonic_GTF_entries_exon_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

# create granges of transcript "type" and "transcript_biotype".
## this is a little complicated because we're splitting by two rows. but basically we have to group_split the exonic and non-exonic entries separately
## the non-exonic will be split by "type" and the exonic will be split by "transcript_biotype".
## then splice the lists together.
## this is because transcript biotypes to be split can be both non-exon or exon, whereas non-exon/exon to be split are always in one transcript_biotype.
list_split_ensembl_transcript_types_and_biotypes <- purrr::splice(
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type != "exon") %>%
    dplyr::group_split(type) %>%
    set_names(purrr::map(.x = ., .f = ~.x$type %>% unique)),
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type == "exon") %>%
    dplyr::group_split(transcript_biotype) %>%
    set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique))
) %>% flatten

list_granges_ensembl_transcript_types <- list_split_ensembl_transcript_types_and_biotypes %>%
  purrr::map(~toGRanges(.x[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                          # turn chr column into chr1 chr2 etc...
                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                          type_convert %>% 
                          # data frame is absolutely necessary for regioneR.
                          as.data.frame))

# NOTE: not planning to do "transcript_biotype" anymore.

# list_granges_ensembl_transcript_biotypes <- tibble_ref_gtf_original %>%
#   dplyr::filter(type == "exon") %>%
#   dplyr::group_split(transcript_biotype) %>%
#   set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique)) %>%
#   purrr::map(~toGRanges(.x[, c("chr", "start", "end")] %>% 
#                           # turn chr column into chr1 chr2 etc...
#                           dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
#                           type_convert %>% 
#                           # data frame is absolutely necessary for regioneR.
#                           as.data.frame))

# list_granges_ensembl_transcript_by_type_and_biotype <- purrr::splice(list_granges_ensembl_transcript_types, list_granges_ensembl_transcript_biotypes)

```

#### construct the effective CDSome

```{r}

# extract CDS entries only
tibble_CDS_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "CDS", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_CDS_GTF_entries_unique <- tibble_CDS_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutele necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_CDS_GTF_entries_unique <- granges_CDS_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_CDS_GTF_entries <- tibble_CDS_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_CDS_GTF_entries) <- list_CDS_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_CDS_GTF_entries <- list_CDS_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO CDS-RELATIVE TOPOLOGY MAPPING
list_CDS_GTF_entries_genome_to_CDS_relative_mapping <- future_map(.x = list_CDS_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_CDS_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_CDS_relative_end <- vec_sum_of_widths
                                                            vec_CDS_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("CDS_relative_start" = vec_CDS_relative_start,
                                                                                              "CDS_relative_end" = vec_CDS_relative_end)
                                                            
                                                          }, .progress = TRUE)

# create granges of the effective CDSome
## first get start and end based on the CDS relative coords
tibble_effective_CDSome <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$CDS_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_CDSome <- toGRanges(tibble_effective_CDSome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

```

### Preprocessing: convert differential positions into UNIQUE Granges and convert to exon-relative coords.

#### differential VSR regions for JUM and PSI-Sigma - cast onto effective transcriptome

```{r}

# JUM - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_VSR_genome.relative_chr.start.end <- tibble_AS.event.IDs_chr_start_end_differential %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_VSR_genome.relative_chr.start.end[tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      } )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_JUM_differential_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_VSR_transcriptome_relative_coords <- toGRanges(tibble_JUM_differential_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_differential_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_JUM_differential_VSR_transcriptome_relative_coords, granges_JUM_differential_VSR_transcriptome_relative_coords)

# PSI-Sigma - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end <- tibble_psisigma_differential_chr_start_end %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end[tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_PSIsigma_differential_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_VSR_transcriptome_relative_coords <- toGRanges(tibble_PSIsigma_differential_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_PSIsigma_differential_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_PSIsigma_differential_VSR_transcriptome_relative_coords, granges_PSIsigma_differential_VSR_transcriptome_relative_coords)

```

#### constitutive VSR regions for JUM and PSI-Sigma - cast onto effective transcriptome

```{r}

# JUM - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_constitutive_VSR_genome.relative_chr.start.end <- tibble_AS.event.IDs_chr_start_end_constitutive %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_constitutive_VSR_genome.relative_chr.start.end[tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_JUM_constitutive_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_constitutive_VSR_transcriptome_relative_coords <- toGRanges(tibble_JUM_constitutive_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_constitutive_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_JUM_constitutive_VSR_transcriptome_relative_coords, granges_JUM_constitutive_VSR_transcriptome_relative_coords)

# PSI-Sigma - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end <- tibble_psisigma_constitutive_chr_start_end %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end[tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- toGRanges(tibble_PSIsigma_constitutive_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords)

```

#### differential exonic positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_all.RNA, granges_JUM_differential_exonic_regions_all.RNA)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_all.RNA, granges_PSIsigma_differential_exonic_regions_all.RNA)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_proteome.filtered.RNA, granges_JUM_differential_exonic_regions_proteome.filtered.RNA)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA, granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

```

#### differential CDS positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)

```

### Preprocessing: convert topology for fixed (target) regions

#### cast the public CLIP-seq data onto transcriptome

```{r}

# create tibble combining all the CLIP-Seq data
tibble_clipseq_binding_sites_combined <- purrr::map2(.x = list_clipseq_tibbles, .y = names(list_clipseq_tibbles), .f = ~.x %>% dplyr::mutate("sample" = .y) %>% dplyr::mutate_all(as.character)) %>%
  purrr::reduce(dplyr::bind_rows)

## group-split the non-exonic entries by chromosome so we can map2 over both.
list_clipseq_binding_sites_split_by_chr <- purrr::map(.x = names(list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping),
                                                      .f = ~tibble_clipseq_binding_sites_combined[tibble_clipseq_binding_sites_combined$chr == .x, ]) %>% 
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)

## map2 over exonic and non-exonic GTF entries.
list_clipseq_binding_sites_transcriptome_relative_coords <- future_map2(.x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping,
                                                                        .y = list_clipseq_binding_sites_split_by_chr,
                                                                        .f = function(a1, a2) {
                                                                          
                                                                          # DEBUG ###
                                                                          # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
                                                                          # a2 <- list_clipseq_binding_sites_split_by_chr[[1]]
                                                                          ###########
                                                                          
                                                                          # list-ify the non-exonic entries
                                                                          list_non_exonic_subset <- a2 %>% array_tree
                                                                          # loop thru each element, find overlapping exonic interval, subtract 
                                                                          list_non_exonic_subset_transcript_relative_coords <- future_map(
                                                                            .x = list_non_exonic_subset,
                                                                            .f = function(b1) {
                                                                              
                                                                              # DEBUG ###
                                                                              # b1 <- list_non_exonic_subset[[1]]
                                                                              ###########
                                                                              
                                                                              tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
                                                                              
                                                                              # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
                                                                              shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcriptome_relative_start
                                                                              transcriptome_relative_start <- (b1$start %>% type.convert) - shift
                                                                              transcriptome_relative_end <- (b1$end %>% type.convert) - shift
                                                                              
                                                                              output_tibble <- splice(
                                                                                b1,
                                                                                "transcriptome_relative_start" = transcriptome_relative_start %>% list,
                                                                                "transcriptome_relative_end" = transcriptome_relative_end %>% list
                                                                              ) %>% as_tibble
                                                                              
                                                                              return(output_tibble)
                                                                              
                                                                            }, .progress = TRUE)
                                                                          
                                                                        }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_clipseq_binding_sites_transcriptome_relative_coords <- list_clipseq_binding_sites_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

# group_split back into each individual contributing sample
list_clipseq_binding_sites_transcriptome_relative_coords_separated_by_sample <- purrr::splice(
  tibble_clipseq_binding_sites_transcriptome_relative_coords %>% 
    dplyr::group_split(sample) %>%
    set_names(purrr::map(.x = ., .f = ~.x$sample %>% unique))
) %>% flatten

list_granges_clipseq_binding_sites_separated_by_sample <- list_clipseq_binding_sites_transcriptome_relative_coords_separated_by_sample %>%
  purrr::map(~toGRanges(.x[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                          # turn chr column into chr1 chr2 etc...
                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                          type_convert %>% 
                          # data frame is absolutely necessary for regioneR.
                          as.data.frame))

```

#### get all the genome-relative positions of CDS nucleotides for every ENSP id

```{r}

# tibble_ENSP_to_genome_relative_CDS_positions <- tibble_ref_gtf_original %>% 
#   dplyr::filter(type == "CDS") %>% 
#   dplyr::group_split(protein_id) %>% 
#   future_map(.f = ~list("protein_id" = .x$protein_id %>% unique, "chr" = .x$chr %>% unique, "vec_all_parent_ENSP_CDS_positions_sorted" = purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% sort), .progress = TRUE, .options = future_options(globals = FALSE)) %>% 
#   future_map(.f = ~as_tibble(.x) %>% nest(data = "vec_all_parent_ENSP_CDS_positions_sorted") %>% dplyr::rename("vec_all_parent_ENSP_CDS_positions_sorted" = "data"), .progress = TRUE, .options = future_options(globals = c("as_tibble", "nest", "dplyr::rename"))) %>% 
#   rbindlist %>% as_tibble

# save(tibble_ENSP_to_genome_relative_CDS_positions, file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

load(file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

load(file = paste(reference_data_dir, "tibble_interpro_domains_cast_onto_genome.tibble", sep = ""))

```

#### Cast biomart regions onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(reference_data_dir, "table_biomart_ENSP_to_", .x, ".txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble", "reference_data_dir"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

# filter the interpro entries for the non-family entries only
list_of_tibbles_biomart_domain_annotation <- purrr::modify_at(.x = list_of_tibbles_biomart_domain_annotation,
                                                              .at = "interpro",
                                                              .f = ~dplyr::semi_join(.x, tibble_non_family_interpro_entries %>% dplyr::rename("interpro" = "Accession"), by = "interpro"))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

list_of_tibbles_biomart_regions_cast_onto_genome <- future_imap(.x = list_of_tibbles_biomart_domain_annotation, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- list_of_tibbles_biomart_domain_annotation[["interpro"]]
  ###########
  
  cat("\nnow processing: ", a2, "\n")
  
  tibble_sorted_CDS_relative_positions <- a1 %>% 
    add_column("CDS_relative_coords_start" = ((3*.$start) - 2), "CDS_relative_coords_end" = (3*.$end)) %>% 
    dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
    dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
    # some ENSP ids from interpro are not in ensembl.
    dplyr::filter(is.na(chr) != TRUE) 
  
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  vec_all_genome_relative_coords_of_item <- future_map2(
    .x = tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions`, 
    .y = tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted`, 
    .f = function(b1, b2) {
      
      # DEBUG ###
      # b1 <- tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions` %>% .[[1]]
      # b2 <- tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted` %>% .[[1]]
      ###########
      
      vec_parent_ENSP_CDS_positions <- b2 %>% unlist
      
      vec_parent_ENSP_CDS_positions[b1] %>% return
      
    }, .progress = TRUE, .options = future_options(globals = FALSE))
  
  nucleotide_width <- purrr::map(.x = vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist
  
  # add the genome-relative coords and nucleotide width in
  final_tibble_with_genome_relative_coords <- tibble_sorted_CDS_relative_positions %>% 
    add_column("vec_all_genome_relative_coords_of_item" = vec_all_genome_relative_coords_of_item,
               "nucleotide_width" = nucleotide_width)
  
}, .progress = TRUE ) 

# drop the columns of all ENSP positions. we dont need them anymore.
list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted))
# drop empty "chr" rows
# list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::filter(is.na(chr) != TRUE))

# save(list_of_tibbles_biomart_regions_cast_onto_genome, file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 8),
#           tweak(multiprocess, workers = 8))
# )

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the CDS.
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_biomart_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_biomart_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_biomart_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_biomart_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the biomart entries, one element per row.
        list_biomart_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping exonic interval, subtract 
        list_biomart_subset_exome_relative_coords <- future_map(
          .x = list_biomart_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_biomart_subset[[1]]
            ###########
            
            tibble_matching_exome_entry <- b1[which(b1$start <= c1$start %>% type.convert & b1$end >= c1$end %>% type.convert), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_exome_entry$start - tibble_matching_exome_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_biomart_subset_exome_relative_coords <- list_biomart_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_biomart_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_biomart_regions_exome_relative_coords_single_annotation <- list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_biomart_regions_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative biomart regions into granges
list_granges_biomart_regions_exome_relative <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_biomart_region <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutele necessary for regioneR.
                                          as.data.frame)
    
    return(granges_biomart_region)
    
  }, .progress = TRUE )

```

#### cast dbPTM sites onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# get ENSP to uniprotkb_entry mapping
# tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
# type_convert %>% 
# as_tibble %>%
# na.omit

tibble_ENSP_to_uniprotkb <- read.delim(file = paste(reference_data_dir, "table_ENSP_to_uniprot_entry_mapping_38.98.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% as_tibble

# convert uniprotkb_entry into ENSP
tibble_dbPTM_allhuman_annotations_with_ENSP <- dplyr::left_join(tibble_dbPTM_allhuman_annotations, tibble_ENSP_to_uniprotkb, by = "uniprotkb_entry") %>% 
  dplyr::filter(is.na(ensembl_peptide_id) != TRUE) %>% type_convert

# cast onto genome.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_with_ENSP %>% 
  add_column("CDS_relative_coords_start" = ((3*.$modified_residue_position) - 2), "CDS_relative_coords_end" = (3*.$modified_residue_position)) %>% 
  dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
  dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
  # some ENSP ids from interpro are not in ensembl.
  dplyr::filter(is.na(chr) != TRUE) %>%
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  dplyr::mutate("vec_all_genome_relative_coords_of_item" = purrr::map2(.x = .$vec_all_CDS_relative_positions, .y = .$vec_all_parent_ENSP_CDS_positions_sorted, .f = ~.y %>% unlist %>% .[.x], .progress = TRUE, .options = future_options(globals = FALSE))) %>%
  dplyr::mutate("nucleotide_width" = purrr::map(.x = .$vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist)

# drop the columns of all ENSP positions. we dont need them anymore.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted)
# save(tibble_dbPTM_allhuman_annotations_cast_onto_genome, file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# split by PTM type
list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>%
  dplyr::group_split(PTM_type) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges <- future_map(
  .x = list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the *exome
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the entries, one element per row.
        list_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping CDS interval, subtract 
        list_PTM_subset_exome_relative_coords <- future_map(
          .x = list_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_subset[[1]]
            ###########
            
            tibble_matching_CDS_entry <- b1[which(b1$start <= c1$start %>% type.convert & b1$end >= c1$end %>% type.convert), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_CDS_entry$start - tibble_matching_CDS_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_PTM_subset_exome_relative_coords <- list_PTM_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_PTM_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_PTM_sites_exome_relative_coords_single_annotation <- list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_PTM_sites_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative PTM sites into granges
list_granges_PTM_sites_exome_relative <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_PTM_sites <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutely necessary for regioneR.
                                          as.data.frame)
    
    return(granges_PTM_sites)
    
  }, .progress = TRUE )

```

### Permutation test

#### Set up all source lists

```{r}

# granges_effective_CDSome
# granges_effective_exome 

# list_granges_ensembl_transcript_types
# list_granges_biomart_regions_CDS_relative 
# list_granges_PTM_sites_CDS_relative

list_granges_transcriptomic_VSR_positions <- list(
  "JUM_differential_VSR" = granges_JUM_differential_VSR_transcriptome_relative_coords,
  "PSIsigma_differential_VSR" = granges_PSIsigma_differential_VSR_transcriptome_relative_coords,
  "JUM_constitutive_VSR" = granges_JUM_constitutive_VSR_transcriptome_relative_coords,
  "PSIsigma_constitutive_VSR" = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords
)

list_granges_exonic_differential_positions <- list(
  "JUM_exonic_unfiltered" = granges_JUM_differential_exonic_regions_all.RNA,
  "PSIsigma_exonic_unfiltered" = granges_PSIsigma_differential_exonic_regions_all.RNA,
  "JUM_exonic_proteome_filtered" = granges_JUM_differential_exonic_regions_proteome.filtered.RNA,
  "PSIsigma_exonic_proteome_filtered" = granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

list_granges_CDS_differential_positions <- list(
  "JUM_CDS_unfiltered" = granges_JUM_differential_CDS_regions_all.RNA,
  "PSIsigma_CDS_unfiltered" = granges_PSIsigma_differential_CDS_regions_all.RNA,
  "JUM_CDS_proteome_filtered" = granges_JUM_differential_CDS_regions_proteome.filtered.RNA,
  "PSIsigma_CDS_proteome_filtered" = granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA)

```

#### JUM/PSI-SIgma VSRs and CLIP-seq regions - **TRANSCRIPTOME**

```{r}

plan(list(tweak(multisession, workers = 2),
          tweak(multisession, workers = 8),
          tweak(multisession, workers = 8))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: transcript type
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_transcript_types <- future_map(
  .x = list_granges_transcriptomic_VSR_positions[c("JUM_differential_VSR", "PSIsigma_differential_VSR")], 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_transcriptomic_VSR_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_clipseq_binding_sites_separated_by_sample,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_clipseq_binding_sites_separated_by_sample[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        # NOTE!!!!! WE ARE MOVING THE *CLIP-SEQ* REGIONS, NOT THE DIFFERENTIAL JUM/PSI-SIGMA REGIONS!!
        # THIS IS BECAUSE WE WANT TO FIND OUT WHETHER THE CLIP-SEQ REGIONS ARE DISTINGUISHABLE FROM PURELY RANDOM POSITIONS!!!
        regioneR::permTest(A = b1,
                           B = a1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_transcriptome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 8) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_transcript_types, file = paste(results_dir, "list_permtest_JUM_PSIsigma_VSR_vs_clipseq_binding_sites.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_transcript_types_pvalues <- list_permtest_exonic_transcript_types %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

# plot the perm tests
purrr::map_depth(.x = list_permtest_exonic_transcript_types, .depth = 2, .f = ~.x %>% plot)

```

#### ensembl transcript-level regions - loop thru each type of region - **EXOME**

- we use random shuffle permutations at the level of the exome or CDS. This is because contiguity is achieved in the exome and CDS.

```{r}

plan(list(tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: transcript type
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_transcript_types <- future_map(
  .x = list_granges_exonic_differential_positions[c("JUM_exonic_unfiltered", "PSIsigma_exonic_unfiltered")], 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_ensembl_transcript_types,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_ensembl_transcript_types[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 8) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_transcript_types, file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_transcript_types_pvalues <- list_permtest_exonic_transcript_types %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### biomarts regions - loop thru each type of region - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 7),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_biomart_regions <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_biomart_regions_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_biomart_regions_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_biomart_regions, file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_biomart_regions_pvalues <- list_permtest_exonic_biomart_regions %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### PTMs - loop thru each type of PTM - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_PTMs <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_PTM_sites_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_PTM_sites_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_PTMs, file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_PTMs_pvalues <- list_permtest_exonic_PTMs %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))


```

```{r}

# optional: save workspace for debugging because i'm going to run this overnight and go to sleep.
save.image(file = "/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/multiomic_synthesis/source/22092020_topology_conversion_bootstrapping.RData")

stop("Proteome section finished")

```

# benchmark performance of NMD flagger

comparisons are done at the level of transcripts.

```{r}

tibble_ref_gtf_with_NMD_flagged_unique_transcripts <- tibble_ref_gtf_with_NMD_flagged_E2 %>% .[-which(is.na(.$transcript_id)), c("transcript_id", "seqnames", "strand", "start", "end", "transcript_biotype", "NMD_candidate")] %>% dplyr::distinct(transcript_id, .keep_all = TRUE) %>% add_column("identifier" = paste(.$seqnames, ":", .$start, "-", .$end, sep = ""))

# get row indices of those transcripts with ref. annotated NMD
row.indices_ref_NMD <- which(tibble_ref_gtf_with_NMD_flagged_unique_transcripts$transcript_biotype == "nonsense_mediated_decay")

# get row indices of those transcripts flagged as NMD
row.indices_flagged_NMD <- grep(x = tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate, pattern = "TRUE")

message("number of reference transcripts with reference NMD annotation: ", row.indices_ref_NMD %>% length, " (", (row.indices_ref_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of reference transcripts flagged as NMD: ", row.indices_flagged_NMD %>% length, " (", (row.indices_flagged_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of transcripts flagged as NMD in common with annotation: ", intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)
message("jaccard: ", (intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)/(union(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length))

# ggplot of the transcript_biotype of NMD candidates

## neat descending order of x-axis
tibble_frequency_distribution <- tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% 
  dplyr::filter(NMD_candidate == "TRUE") %>% 
  dplyr::group_by(transcript_biotype) %>% 
  dplyr::summarise("count_per_transcript_biotype" = n()) %>% 
  dplyr::arrange(desc(count_per_transcript_biotype))

message("percent protein_coding of total: ", (tibble_frequency_distribution[tibble_frequency_distribution$transcript_biotype == "protein_coding", "count_per_transcript_biotype"] %>% paste %>% as.numeric)*100/sum(tibble_frequency_distribution$count_per_transcript_biotype), "%")

x_axis_order <- tibble_frequency_distribution %>% .$transcript_biotype %>% unique

ggplot(data = tibble_ref_gtf_with_NMD_flagged_unique_transcripts[tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate == "TRUE", ]) +
  geom_bar(mapping = aes(x = transcript_biotype, y = ..count..)) +
  geom_label(stat = "count", aes(x = transcript_biotype, label = ..count..)) +
  scale_x_discrete(breaks = x_axis_order, limits = x_axis_order) +
  ggtitle("Common Ensembl transcript_biotype annotations associated with flagged NMD transcripts
          (minimum 5 exons)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

# sQTL and disease ontology - JUM and PSI-Sigma

## Cross reference SNPs from the GWAS catalog

### find SNPs which lie in AS regions

#### prepare bootstrapping tools - bootstrap for SNP regions.

```{r}

library(regioneR)

library(BSgenome.Hsapiens.UCSC.hg38)

set.seed(7)

options(mc.cores = 16)

```

At the present time, we are looking for SNPs in whole LSV regions for both JUM and PSI-Sigma. This is because mutations can occur at the cis-ESS/ESE/ISS/ISEs, which are not always in the exons/introns of interest.

#### calculate overlap

##### JUM differential

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_differential <- tibble(
  "AS_event_ID" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_differential_array.tree <- tibble_AS.event.IDs_chr_start_end_differential %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential <- future_map(.x = list_JUM_AS.event.IDs_differential_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                CHR_POS >= .x$start %>% as.numeric &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_JUM_differential_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

# get a tally of traits
tibble_JUM_differential_AS.event.ID_snps_summary_by_trait <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_differential_AS.event.ID_snps_summary_by_context <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(context_tally_JUM_differential))

```

##### JUM constitutive

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_constitutive <- tibble(
  "AS_event_ID" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_constitutive_array.tree <- tibble_AS.event.IDs_chr_start_end_constitutive %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive <- future_map(.x = list_JUM_AS.event.IDs_constitutive_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                CHR_POS >= .x$start %>% as.numeric &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_JUM_constitutive))

```

##### psi-sigma differential

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_differential_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_differential_chr_start_end_array.tree <- tibble_psisigma_differential_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_differential <- future_map(.x = list_psisigma_differential_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                               CHR_POS >= .x$start %>% as.numeric &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_psisigma_differential_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_differential_all_overlapping_snps_filtered <- tibble_psisigma_differential_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_differential_snps_summary_by_trait <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_differential_snps_summary_by_context <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_differential))

```

##### psi-sigma constitutive

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_constitutive_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_constitutive_chr_start_end_array.tree <- tibble_psisigma_constitutive_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_constitutive <- future_map(.x = list_psisigma_constitutive_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                               CHR_POS >= .x$start %>% as.numeric &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_psisigma_constitutive_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_constitutive_all_overlapping_snps_filtered <- tibble_psisigma_constitutive_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_constitutive_snps_summary_by_trait <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::summarise("trait_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_constitutive_snps_summary_by_context <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_constitutive))

```

#### combine overlap data

```{r}

# merge trait and context tally tables together for all data series and melt
long_tibble_combined_overlap_traits <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait, 
                                    tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait, 
                                    tibble_psisigma_differential_snps_summary_by_trait,
                                    tibble_psisigma_constitutive_snps_summary_by_trait) %>% 
  purrr::reduce(dplyr::left_join, by = "DISEASE/TRAIT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange((trait_tally_JUM_differential * trait_tally_JUM_constitutive * trait_tally_PSIsigma_differential * trait_tally_PSIsigma_constitutive) ^ (1/4)) %>%
  na.omit %>%
  tail(n = 8) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "DISEASE/TRAIT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("trait_tally_PSIsigma_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_JUM_constitutive", "trait_tally_JUM_differential")); return(column)} )

long_tibble_combined_overlap_contexts <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_context, 
                                      tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context, 
                                      tibble_psisigma_differential_snps_summary_by_context,
                                      tibble_psisigma_constitutive_snps_summary_by_context) %>% 
  purrr::reduce(dplyr::left_join, by = "CONTEXT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange(((context_tally_JUM_differential) ^ (1/4)) * 
                   ((context_tally_JUM_constitutive) ^ (1/4)) * 
                   ((context_tally_PSIsigma_differential) ^ (1/4)) * 
                   ((context_tally_PSIsigma_constitutive) ^ (1/4))) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "CONTEXT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("context_tally_PSIsigma_constitutive", "context_tally_PSIsigma_differential", "context_tally_JUM_constitutive", "context_tally_JUM_differential")) ; return(column)} )

```

#### bootstrapping to calculate p-value of region overlapping with SNP

##### Filter for SNPs only in transcript regions, cast onto effective transcriptome

We have to replace the "CHR_POS" values in the ebi gwas table with the corresponding transcriptome-relative coords.

```{r}

plan(list(tweak(multiprocess, workers = 25),
          tweak(multiprocess, workers = 8))
)

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- tibble_ebi_gwas_catalog_deduped %>% 
  dplyr::mutate_at(.vars = "CHR_ID", .funs = trimws) %>%
  dplyr::group_split(CHR_ID) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$`CHR_ID` %>% unique) %>% unlist)

## map2 over transcriptome-mapping file
list_ebi_gwas_catalog_deduped_transcriptome_relative <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names] %>% .[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the raw co-ords to be converted
    list_raw_coords_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_transcript_relative_coords <- future_map(
      .x = list_raw_coords_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_raw_coords_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$CHR_POS %>% type.convert & a1$end >= b1$CHR_POS %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_position <- (b1$CHR_POS %>% type.convert) - shift
        
        # update list
        updated_list <- b1
        
        if (tibble_matching_transcriptomic_entry %>% nrow > 0) {
          
          updated_list$CHR_POS <- transcriptome_relative_position
          
        } else {
          
          updated_list$CHR_POS <- NA
          
        }
        
        suppressMessages(suppressWarnings(
          return(updated_list %>% as_tibble)
        ))
          
      }, .options = future_options(globals = c("a1")) )
      
      return(list_transcript_relative_coords)
      
  }, .progress = TRUE) 


tibble_ebi_gwas_catalog_deduped_transcriptome_relative <- list_ebi_gwas_catalog_deduped_transcriptome_relative %>% flatten %>% rbindlist %>% as_tibble

```

##### JUM differential
###### traits

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_traits <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT` %>% .[[1]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>% 
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(granges_JUM_differential_VSR_transcriptome_relative_coords[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                                                         
                                             permtest_result <- permTest(A = granges_JUM_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_traits <- list_permtest_results_JUM_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_traits, file = paste(results_dir, "list_permtest_results_JUM_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_contexts <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT` %>% .[[10]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutely necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_differential[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_contexts <- list_permtest_results_JUM_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_contexts, file = paste(results_dir, "list_permtest_results_JUM_differential_contexts.Rlist", sep = ""))

```

##### JUM constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_traits <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = FALSE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_traits <- list_permtest_results_JUM_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_traits, file = paste(results_dir, "list_permtest_results_JUM_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_contexts <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_contexts <- list_permtest_results_JUM_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_contexts, file = paste(results_dir, "list_permtest_results_JUM_constitutive_contexts.Rlist", sep = ""))

```

##### PSI-Sigma differential
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_traits <- future_map(.x = tibble_psisigma_differential_snps_summary_by_trait[tibble_psisigma_differential_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_differential_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_traits <- list_permtest_results_PSIsigma_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_contexts <- future_map(.x = tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_contexts <- list_permtest_results_PSIsigma_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_contexts.Rlist", sep = ""))

```

##### PSI-Sigma constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_traits <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_trait[tibble_psisigma_constitutive_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_traits <- list_permtest_results_PSIsigma_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_contexts <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_contexts <- list_permtest_results_PSIsigma_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_contexts.Rlist", sep = ""))

```

##### combine bootstrap significance tibbles

```{r}

long_tibble_combined_significance_traits <- list(tibble_significance_logical_test_JUM_differential_traits, 
                                                 tibble_significance_logical_test_JUM_constitutive_traits, 
                                                 tibble_significance_logical_test_PSIsigma_differential_traits,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_traits) %>% 
  purrr::reduce(dplyr::full_join, by = "DISEASE/TRAIT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "trait_tally_")} )

long_tibble_combined_significance_contexts <- list(tibble_significance_logical_test_JUM_differential_contexts, 
                                                 tibble_significance_logical_test_JUM_constitutive_contexts, 
                                                 tibble_significance_logical_test_PSIsigma_differential_contexts,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_contexts) %>% 
  purrr::reduce(dplyr::full_join, by = "CONTEXT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "context_tally_")} )

```

#### combine the traits and significance tables and plot on the same graph

```{r}

long_tibble_combined_overlap_and_significance_traits <- dplyr::left_join(long_tibble_combined_overlap_traits, long_tibble_combined_significance_traits, by = c("DISEASE/TRAIT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("DISEASE/TRAIT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`DISEASE/TRAIT` <- factor(x = x$`DISEASE/TRAIT`, levels = long_tibble_combined_overlap_traits$`DISEASE/TRAIT` %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_traits$tool_diff.cons %>% levels); return(y)} )
long_tibble_combined_overlap_and_significance_contexts <- dplyr::left_join(long_tibble_combined_overlap_contexts, long_tibble_combined_significance_contexts, by = c("CONTEXT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("CONTEXT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`CONTEXT` <- factor(x = x$`CONTEXT`, levels = long_tibble_combined_overlap_contexts$CONTEXT %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_contexts$tool_diff.cons %>% levels); return(y)} )

# combined tally plot, traits
ggplot(data = long_tibble_combined_overlap_and_significance_traits, aes(x = `DISEASE/TRAIT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 30 + ((floor(tally %>% log10) + 1) * 20), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_traits$tally %>% max * 1.2)) +
  ggtitle("Top 8 traits, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 14, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 14, height = 16, units = "cm")

# combined tally plot, contexts
ggplot(data = long_tibble_combined_overlap_and_significance_contexts, aes(x = `CONTEXT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 150 + ((floor(tally %>% log10) + 1) * 250), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 30)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_contexts$tally %>% max * 1.4)) +
  ggtitle("SNP Contexts tally, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 16, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 16, height = 16, units = "cm")

stop("GWAS done")

```

### Plot distances from junc/exon boundaries to SNPs

STRATEGY: 
1. loop thru ALL SNPs
2. find nearest flanking upstream/downstream boundary, append to table.
3. compute distance which is SNP - boundary.

junc boundaries: sub_junc_coor for differential/const.
exon boundaries: all diff or all const

```{r}

# subset by chr for more efficient looping
list_JUM_junc_diff_subset_by_chr <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("AS_event_chr", "sub_junction_start_coor", "sub_junction_end_coor")] %>% dplyr::add_row("AS_event_chr" = "Y", "sub_junction_start_coor" = NA, "sub_junction_end_coor" = NA) %>% dplyr::group_split(AS_event_chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$AS_event_chr %>% unique) %>% unlist)
list_JUM_junc_const_subset_by_chr <- tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[, c("AS_event_chr", "sub_junction_start_coor", "sub_junction_end_coor")] %>% dplyr::group_split(AS_event_chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$AS_event_chr %>% unique) %>% unlist)

list_PSIsigma_exon_diff_subset_by_chr <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[, c("chr", "diff_exon_start", "diff_exon_end")] %>% dplyr::group_split(chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
list_PSIsigma_exon_const_subset_by_chr <- tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na[, c("chr", "diff_exon_start", "diff_exon_end")] %>% dplyr::group_split(chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 30),
          tweak(multiprocess, workers = 4))
)

list_gwas_catalog_with_junc.exon_boundary_info <- furrr::future_pmap(
  .l = list("a1" = list_tibble_ebi_gwas_catalog_by_chr,
            "a2" = list_JUM_junc_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a3" = list_JUM_junc_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a4" = list_PSIsigma_exon_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a5" = list_PSIsigma_exon_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)]),
  .f = function(a1, a2, a3, a4, a5) {
    
    # DEBUG ###
    # a1 <- list_tibble_ebi_gwas_catalog_by_chr[[1]]
    # a2 <- list_JUM_junc_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a3 <- list_JUM_junc_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a4 <- list_PSIsigma_exon_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a5 <- list_PSIsigma_exon_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    ###########
    
    # get all the junc/exon start/end's
        vector_sub_junc_diff_starts <- a2$sub_junction_start_coor
        vector_sub_junc_diff_ends <- a2$sub_junction_end_coor
        
        vector_sub_junc_const_starts <- a3$sub_junction_start_coor
        vector_sub_junc_const_ends <- a3$sub_junction_end_coor
        
        vector_exon_diff_starts <- a4$diff_exon_start
        vector_exon_diff_ends <- a4$diff_exon_end
        
        vector_exon_const_starts <- a5$diff_exon_start
        vector_exon_const_ends <- a5$diff_exon_end
    
    furrr::future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[1]]
        ###########
        
        # find nearest match to all junc/exon boundaries
        purrr::splice(
          b1, 
          "nearest_JUM.junc.diff_start" = vector_sub_junc_diff_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_starts)))] %>% unique,
          "nearest_JUM.junc.diff_end" = vector_sub_junc_diff_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_ends)))] %>% unique,
          
          "nearest_JUM.junc.const_start" = vector_sub_junc_const_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_starts)))] %>% unique,
          "nearest_JUM.junc.const_end" = vector_sub_junc_const_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_ends)))] %>% unique,
          
          "nearest_PSIsigma.exon.diff_start" = vector_exon_diff_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_starts)))] %>% unique,
          "nearest_PSIsigma.exon.diff_end" = vector_exon_diff_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_ends)))] %>% unique,
          
          "nearest_PSIsigma.exon.const_start" = vector_exon_const_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_starts)))] %>% unique,
          "nearest_PSIsigma.exon.const_end" = vector_exon_const_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_ends)))] %>% unique
        ) %>% 
          # ... and also the differences.
          # should be SNP - boundary so that the SNP distances from boundary can be read from 5' to 3'.
          purrr::splice(
            "difference_JUM.junc.diff_start" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.diff_start,
            "difference_JUM.junc.diff_end" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.diff_end,
            
            "difference_JUM.junc.const_start" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.const_start,
            "difference_JUM.junc.const_end" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.const_end,
            
            "difference_PSIsigma.exon.diff_start" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.diff_start,
            "difference_PSIsigma.exon.diff_end" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.diff_end,
            
            "difference_PSIsigma.exon.const_start" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.const_start,
            "difference_PSIsigma.exon.const_end" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.const_end
          ) %>% 
          flatten %>%
          as_tibble %>%
          return
        
      }, .progress = TRUE ) %>% # L2
      return
    
  }, .progress = TRUE)

# rbind and tibblise
tibble_gwas_catalog_with_junc.exon_boundary_info <- list_gwas_catalog_with_junc.exon_boundary_info %>% flatten %>% rbindlist(fill = TRUE) %>% as_tibble

# plot

difference_JUM.junc.diff_start
difference_JUM.junc.diff_end
difference_JUM.junc.const_start
difference_JUM.junc.const_end
difference_PSIsigma.exon.diff_start
difference_PSIsigma.exon.diff_end
difference_PSIsigma.exon.const_start
difference_PSIsigma.exon.const_end 

vector_differences_to_plot <- tibble_gwas_catalog_with_junc.exon_boundary_info[tibble_gwas_catalog_with_junc.exon_boundary_info$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  # .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  .$difference_JUM.junc.diff_end %>% 
  na.omit

vector_differences_to_plot <- vector_differences_to_plot[vector_differences_to_plot < 400 & vector_differences_to_plot > -400]

plot(
  density(vector_differences_to_plot, bw = 3, freq = TRUE),
  ylab = "Frequency"
)

ggplot(tibble("vector_differences_to_plot" = vector_differences_to_plot)) +
  geom_histogram(aes(x = `vector_differences_to_plot`), binwidth = 10) 

```

### look for coordinate-level overlap between matched SNPs and CLIP-Seq sites

#### retrieve the clip-seq entries that definitively regulate VSRs.

- we first have to extract the list of tibbles describing clip-seq regions that overlapped VSRs.
- then we have to filter by targeted entries (because targets in other clusters don't count)
- then we have to find the overlap with SNPs

```{r}

# list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries

# extract the overlapping clip-seq regions
list_clip_seq_entries_overlapping_VSRs_diff <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap_with_matched_clipseq_regions$")]
list_clip_seq_entries_overlapping_VSRs_diff <- list_clip_seq_entries_overlapping_VSRs_diff[!grepl(x = list_clip_seq_entries_overlapping_VSRs_diff %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")]

# map together to filter by the confirmed target entries.
list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions <- future_map2(
  .x = list_clip_seq_entries_overlapping_VSRs_diff,
  .y = list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries,                                      
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_clip_seq_entries_overlapping_VSRs_diff[[1]]
    # a2 <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries[[1]]
    ###########
    
    tibble_filtered_clipseq_targets <- a1[a1$VSR_AS_event_ID %in% (a2$AS_event_ID %>% na.omit) | a1$VSR_event_region_coords %in% (a2$event_region_coords %>% na.omit), ]
    
    return(tibble_filtered_clipseq_targets)
    
  }, .progress = TRUE)

```

#### calculate overlap

```{r}

plan(list(tweak(multiprocess, workers = 32),
          tweak(multiprocess, workers = 4)))

# match each chr start end with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_public_CLIP_seq_entries_differential <- future_map(
  .x = list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    list_of_subset_tibbles <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[5]]
        ###########
        
        subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == b1$clipseq_chr &
                                                                     CHR_POS %>% type.convert >= b1$clipseq_start %>% type.convert - 2  &
                                                                     CHR_POS %>% type.convert <= b1$clipseq_end %>% type.convert + 2)
        
        subset_tibble <- subset_tibble %>% add_column("CLIP_start" = b1$clipseq_start %>% type.convert,
                                                      "CLIP_end" = b1$clipseq_end %>% type.convert,
                                                      "VSR_AS_event_ID" = b1$VSR_AS_event_ID,
                                                      "VSR_event_region_coords" = b1$VSR_event_region_coords)
        
        return(subset_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column", "dplyr")) )
    
    # rbind and tibblise
    
    return(list_of_subset_tibbles %>% rbindlist %>% as_tibble)
    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "dplyr", "data.table", "tibble")))

save(list_of_gwas_catalog_entries_overlapped_with_public_CLIP_seq_entries_differential, file = paste(results_dir, "list_of_gwas_catalog_entries_overlapped_with_confirmed_public_CLIP_seq_binding_sites_VSR_differential.Rlist", sep = ""))
# load(file = paste(results_dir, "list_of_gwas_catalog_entries_overlapped_with_confirmed_public_CLIP_seq_binding_sites_VSR_differential.Rlist", sep = ""))

```

## Assess whether SNPs lie in Ago2 CLIP binding sites

### Append SNP information to the Ago2 CLIP table

```{r}

# map over the Ago2 tibble and the GWAS catalog tibble by chromosome
## but first, we have to find which chromosomes the lists have in common
chr_in_common <- intersect(list_tibble_ebi_gwas_catalog_by_chr %>% names, list_ago2_iclip_binding_sites_by_chr %>% names)

tibble_ago2_iclip_binding_sites_with_SNP_info <- future_map2(
  .x = list_ago2_iclip_binding_sites_by_chr[chr_in_common],
  .y = list_tibble_ebi_gwas_catalog_by_chr[chr_in_common],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_ago2_iclip_binding_sites_by_chr[chr_in_common][[1]]
    # a2 <- list_tibble_ebi_gwas_catalog_by_chr[chr_in_common][[1]]
    ###########
    
    list_ago2_iclip_per_element_with_snp <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[1]]
        ###########
        
        # create NA otherwise the original iclip data will be erased upon dplyr::bind_cols
        tibble_matching_SNP_entries_na <- a2[1, ]
        tibble_matching_SNP_entries_na[1, ] <- NA
        
        # get SNP entries which fall within the binding site
        tibble_matching_SNP_entries <- a2[which(a2$CHR_POS >= b1$start %>% type.convert &
                                                  a2$CHR_POS <= b1$stop %>% type.convert), ]
        
        # dplyr join the matching SNP entries back onto the binding site entry
        if (tibble_matching_SNP_entries %>% nrow > 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries)
        } else if (tibble_matching_SNP_entries %>% nrow == 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries_na)
        }
        
        return(tibble_binding_site_entry_with_SNP_entry)
        
      } )
    
    return(list_ago2_iclip_per_element_with_snp)
    
  }, .progress = TRUE) %>% flatten %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble


## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                  .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                  .f = function(a1, a2) {
                                                                    
                                                                    # DEBUG ###
                                                                    # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                    # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                    ###########
                                                                    
                                                                    # get chromosome
                                                                    current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                    
                                                                    # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                    vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                    
                                                                    # retrieve iCLIP entries based on logical index
                                                                    tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                    
                                                                    return(purrr::splice(a2,
                                                                                         "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                  }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

```

```{r}

stop("SNP section done")

```

# Bulk JUM, PSI-Sigma and scRNA-Seq Sierra !!! WARNING: TEMPORARILY ON HOLD !!!

## Find extent of genes with differential AS in common between Sierra and JUM/PSI-Sigma

```{r}

vector_sierra_genes_clusterwise <- tibble_sierra_DTU_clusterwise_all_simplified$gene_name %>% unique %>% mixedsort %>% na.omit

vector_JUM_diff_genes <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% mixedsort %>% na.omit

vector_PSIsigma_diff_genes <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% mixedsort %>% na.omit

cat("\nSierra total DS genes: ", vector_sierra_genes_clusterwise %>% length)
cat("\nJUM total DS genes: ", vector_JUM_diff_genes %>% length)
cat("\nPSI-Sigma total DS genes: ", vector_PSIsigma_diff_genes %>% length)

cat("\nSierra and JUM DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_JUM_diff_genes) %>% length)
cat("\nSierra and PSI-Sigma DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_PSIsigma_diff_genes) %>% length)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_JUM_diff_genes),
  category.names = c("Sierra" , "JUM"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_JUM.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "mediumorchid4")
)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_PSIsigma_diff_genes),
  category.names = c("Sierra" , "PSI-Sigma"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_PSIsigma.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "brown4")
)

```

## Find the extent of overlap between the Sierra differential peaks and JUM/PSI-Sigma

```{r}

# list-ify the JUM contributing junctions using array_tree then unpack using strsplit
list_JUM_diff_junctions_array.tree <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("contributing_junction_IDs", "chr", "start", "end", "strand")] %>% 
  array_tree %>% 
  purrr::map_depth(.depth = 2, .f = ~strsplit(.x, split = ";")) %>%
  purrr::map(~.x %>% flatten %>% as_tibble)

# match to Sierra's differential junctions

```


