#     # go back and select only the best matched overlapped reference transcript for feeding into the next steps
#     tibble_overlapping_reference_transcripts <- tibble_overlapping_reference_transcripts[tibble_overlapping_reference_transcripts$hgnc_stable_transcript_ID == best_match_hgnc_variant_name, ]
# }
# loop thru each overlapped reference transcript and get the nomenclature
list_tibble_parent_exons_introns_of_overlapped_ref_transcripts_split_by_hgnc_stable_transcript_ID <- purrr::imap(
.x = tibble_overlapping_reference_transcripts$hgnc_stable_transcript_ID %>% mixedsort,
.f = function(a1, a2) {
print(a2)
# DEBUG ###
# a1 <- tibble_overlapping_reference_transcripts$hgnc_stable_transcript_ID %>% mixedsort %>% .[[1]]
###########
tibble_subset_ref_exons <- tibble_gtf_table[which(tibble_gtf_table$hgnc_stable_transcript_ID == a1 & tibble_gtf_table$type == "exon"), ] %>% .[mixedorder(.$exon_number), ]
## add in intronic entries
# if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
#
#     for (i in (tibble_subset_ref_exons$exon_number %>% .[1:(length(.) - 1)] %>% rev)) {
#
#         tibble_subset_ref_exons <- tibble_subset_ref_exons %>%
#             tibble::add_row(tibble_subset_ref_exons[1, ] %>% dplyr::mutate(
#                 "start" = (tibble_subset_ref_exons[i, ] %>% .$end) + 1 ,
#                 "end" = (tibble_subset_ref_exons[i + 1, ] %>% .$start) - 1,
#                 "type" = "intron",
#                 "exon_number" = i + 0.5
#             ) %>%
#                 dplyr::mutate(
#                     "width" = `end` - `start` + 1
#                 ), .after = i )
#
#     }
#
# } else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
#
#     for (i in (tibble_subset_ref_exons$exon_number %>% .[1:(length(.) - 1)] %>% rev)) {
#
#         tibble_subset_ref_exons <- tibble_subset_ref_exons %>%
#             tibble::add_row(tibble_subset_ref_exons[1, ] %>% dplyr::mutate(
#                 "start" = (tibble_subset_ref_exons[i + 1, ] %>% .$end) + 1 ,
#                 "end" = (tibble_subset_ref_exons[i, ] %>% .$start) - 1,
#                 "type" = "intron",
#                 "exon_number" = i + 0.5
#             ) %>%
#                 dplyr::mutate(
#                     "width" = `end` - `start` + 1
#                 ), .after = i )
#
#     }
#
# } # elif
# test query ends for the closest start/end coords, and where they lie relative to each other.
# QUERY START
closest_ref_vertex_to_the_left_of_query_start <- c(tibble_subset_ref_exons$start, tibble_subset_ref_exons$end) %>% .[. <= (query_start + left_query_shift + left_tolerance)] %>% max
closest_ref_vertex_to_the_right_of_query_start <- c(tibble_subset_ref_exons$start, tibble_subset_ref_exons$end) %>% .[. >= (query_start + left_query_shift - left_tolerance)] %>% min
# if one distance is negative, then the vertex lies within the transcript. if positive, then it lies outside
logical_query_start_is_in_transcript <- length((!is.infinite(c(closest_ref_vertex_to_the_left_of_query_start, closest_ref_vertex_to_the_right_of_query_start))) %>% which) == 2
# deal with the condition that query start is outside the transcript
if (logical_query_start_is_in_transcript == FALSE) {
# find the lowest end coord larger than the left query end
leftmost_exon_start <- tibble_subset_ref_exons$start %>% min
query_start_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$start == leftmost_exon_start), ] %>% .$exon_number
query_start_distance_to_vertex <- leftmost_exon_start - query_start
# get distance modifier
query_start_distance_modifier <- paste("+", query_start_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_start <- paste("5'(", query_start_distance_modifier,"E", query_start_exon_number, ")", sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_start <- paste("(", "E", query_start_exon_number, query_start_distance_modifier, ")3'", sep = "")
}
# if closest_ref_vertex_to_the_left... is a start, then we're in an exon (truncation). otherwise we're in an intron if it's an end (extension).
## exonic
} else if ((any(closest_ref_vertex_to_the_left_of_query_start %in% tibble_subset_ref_exons$start) & any(closest_ref_vertex_to_the_right_of_query_start %in% tibble_subset_ref_exons$end)) | (closest_ref_vertex_to_the_left_of_query_start == closest_ref_vertex_to_the_right_of_query_start)) {
if (closest_ref_vertex_to_the_left_of_query_start == closest_ref_vertex_to_the_right_of_query_start) {
query_start_exon_number <- tibble_subset_ref_exons[which((tibble_subset_ref_exons$end == closest_ref_vertex_to_the_right_of_query_start) | (tibble_subset_ref_exons$start == closest_ref_vertex_to_the_right_of_query_start)), ] %>% .$exon_number
} else {
query_start_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$end == closest_ref_vertex_to_the_right_of_query_start), ] %>% .$exon_number
}
query_start_distance_to_vertex <- (tibble_subset_ref_exons[tibble_subset_ref_exons$exon_number == query_start_exon_number, ] %>% .$end) - query_start + 1
query_start_distance_modifier <- paste("–", query_start_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_start <- paste("E", query_start_exon_number, query_start_distance_modifier, sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_start <- paste(query_start_distance_modifier, "E", query_start_exon_number, sep = "")
}
## intronic
} else if (any(closest_ref_vertex_to_the_left_of_query_start %in% tibble_subset_ref_exons$end) & any(closest_ref_vertex_to_the_right_of_query_start %in% tibble_subset_ref_exons$start)) {
query_start_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$end == closest_ref_vertex_to_the_left_of_query_start), ] %>% .$exon_number
query_start_distance_to_vertex <- query_start - closest_ref_vertex_to_the_left_of_query_start - 1
query_start_distance_modifier <- paste("+", query_start_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_start <- paste("E", query_start_exon_number, query_start_distance_modifier, sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_start <- paste(query_start_distance_modifier, "E", query_start_exon_number, sep = "")
}
}
# QUERY END
closest_ref_vertex_to_the_left_of_query_end <- c(tibble_subset_ref_exons$start, tibble_subset_ref_exons$end) %>% .[. <= (query_end + right_query_shift + right_tolerance)] %>% max
closest_ref_vertex_to_the_right_of_query_end <- c(tibble_subset_ref_exons$start, tibble_subset_ref_exons$end) %>% .[. >= (query_end + right_query_shift - right_tolerance)] %>% min
# if one distance is negative, then the vertex lies within the transcript. if positive, then it lies outside
logical_query_end_is_in_transcript <- length((!is.infinite(c(closest_ref_vertex_to_the_left_of_query_end, closest_ref_vertex_to_the_right_of_query_end))) %>% which) == 2
# deal with the condition that query start is outside the transcript
if (logical_query_end_is_in_transcript == FALSE) {
# find the lowest end coord larger than the left query end
rightmost_exon_end <- tibble_subset_ref_exons$end %>% min
query_end_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$end == rightmost_exon_end), ] %>% .$exon_number
query_end_distance_to_vertex <- query_end - rightmost_exon_end
# get distance modifier
query_end_distance_modifier <- paste("+", query_end_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_end <- paste("(", "E", query_end_exon_number, query_end_distance_modifier, ")3'", sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_end <- paste("5'(", query_end_distance_modifier,"E", query_end_exon_number, ")", sep = "")
}
# if closest_ref_vertex_to_the_left... is a start, then we're in an exon (truncation). otherwise we're in an intron if it's an end (extension).
## exonic
} else if ((any(closest_ref_vertex_to_the_left_of_query_end %in% tibble_subset_ref_exons$start) & any(closest_ref_vertex_to_the_right_of_query_end %in% tibble_subset_ref_exons$end)) | (closest_ref_vertex_to_the_left_of_query_end == closest_ref_vertex_to_the_right_of_query_end)) {
if (closest_ref_vertex_to_the_left_of_query_end == closest_ref_vertex_to_the_right_of_query_end) {
query_end_exon_number <- tibble_subset_ref_exons[which((tibble_subset_ref_exons$end == closest_ref_vertex_to_the_left_of_query_end) | (tibble_subset_ref_exons$start == closest_ref_vertex_to_the_left_of_query_end)), ] %>% .$exon_number
} else {
query_end_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$start == closest_ref_vertex_to_the_left_of_query_end), ] %>% .$exon_number
}
query_end_distance_to_vertex <- query_end - (tibble_subset_ref_exons[tibble_subset_ref_exons$exon_number == query_end_exon_number, ] %>% .$start) + 1
query_end_distance_modifier <- paste("–", query_end_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_end <- paste(query_end_distance_modifier, "E", query_end_exon_number, sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_end <- paste("E", query_end_exon_number, query_end_distance_modifier, sep = "")
}
## intronic
} else if (any(closest_ref_vertex_to_the_left_of_query_end %in% tibble_subset_ref_exons$end) & any(closest_ref_vertex_to_the_right_of_query_end %in% tibble_subset_ref_exons$start)) {
query_end_exon_number <- tibble_subset_ref_exons[which(tibble_subset_ref_exons$start == closest_ref_vertex_to_the_right_of_query_end), ] %>% .$exon_number
query_end_distance_to_vertex <- closest_ref_vertex_to_the_right_of_query_end - query_end - 1
query_end_distance_modifier <- paste("+", query_end_distance_to_vertex, sep = "")
if (tibble_subset_ref_exons$strand %>% .[1] == "+") {
exon_slot_query_end <- paste(query_end_distance_modifier, "E", query_end_exon_number, sep = "")
} else if (tibble_subset_ref_exons$strand %>% .[1] == "-") {
exon_slot_query_end <- paste("E", query_end_exon_number, query_end_distance_modifier, sep = "")
}
}
return(
tibble(
"variant_ID_slot" = a1,
"exon_slot_query_start" = exon_slot_query_start %>% gsub(pattern = "\\+0", replacement = "") %>% gsub(pattern = "\\–0", replacement = ""),
"exon_slot_query_end" = exon_slot_query_end %>% gsub(pattern = "\\+0", replacement = "") %>% gsub(pattern = "\\–0", replacement = ""),
"flag_is_exact_match" = if ((query_start_distance_to_vertex + query_end_distance_to_vertex) == 0) {"FULL"} else if (query_start_distance_to_vertex == 0 | query_end_distance_to_vertex == 0) {"HALF"} else {"NO"},
"query_start_match_distance" = query_start_distance_to_vertex,
"query_end_match_distance" = query_end_distance_to_vertex,
"matched_strand" = tibble_subset_ref_exons$strand %>% .[1],
"intergenic" = FALSE
)
)
} ) # purrr::map
list_tibble_parent_exons_introns_of_overlapped_ref_transcripts_split_by_hgnc_stable_transcript_ID %>%
rbindlist %>% as_tibble %>%
return
} # elif intergenic test
}
# END name_a_single_junction() ###
# SHINY: FUNCTION TO SCREEN INPUT COORDINATES
## input: a vector of co-ordinates to be tested
triage_input_coordinates <- function(vector_input_coordinates, vector_of_expected_chromosomes, expect_stranded = NULL) {
# DEBUG ###
# vector_input_coordinates <- c(
#     "16:89740100-89740803:8",
#     "16:89738975-89739477:+",
#     "16:89739267-89739993:*",
#     "16:89739290-89739477:0",
#     "16:89739554-89739993:.",
#     "8:89738975-89739137",
#     "89738975-89739132",
#     "16:89738975-89739128:-",
#     "16:89738709:89738881"
# )
# vector_input_coordinates <- c(
#     "1:2-3:+"
# )
# expect_stranded <- TRUE
# tibble_gtf_table <- tibble_ref_gtf
###########
if (expect_stranded == TRUE) {
# print(vector_input_coordinates)
# print(tibble_gtf_table)
# check for basic format
if (grep(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)\\:(.*)") %>% length != vector_input_coordinates %>% length) {
warning("Error: Please check the format of your co-ordinates and make sure you have specified the strand.")
return("triage fail")
}
vector_query_chr <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)\\:(.*)", replacement = "\\1")
vector_query_VSR_start <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)\\:(.*)", replacement = "\\2")
vector_query_VSR_end <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)\\:(.*)", replacement = "\\3")
vector_query_strand <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)\\:(.*)", replacement = "\\4")
} else if (expect_stranded == FALSE) {
# check for basic format
if (grep(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)") %>% length != vector_input_coordinates %>% length) {
warning("Error: Please check the format of your co-ordinates and make sure you have specified the strand.")
return("triage fail")
}
vector_query_chr <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)", replacement = "\\1")
vector_query_VSR_start <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)", replacement = "\\2")
vector_query_VSR_end <- gsub(x = vector_input_coordinates, pattern = "^([^\\:]+)\\:([^\\-]+)\\-([^\\:]+)", replacement = "\\3")
}
# check chromosomes
if (vector_query_chr %in% (vector_of_expected_chromosomes) %>% all == FALSE) {
warning("Error: Please check the format of your chromosomes")
return("triage fail")
}
# check start/end for numeric
if (vector_query_VSR_start %>% type.convert %>% is.numeric == FALSE | vector_query_VSR_end %>% type.convert %>% is.numeric == FALSE) {
warning("Error: Please check the format of your start/end co-ordinates")
return("triage fail")
}
# check start/end for order. end must be > start
if (any((vector_query_VSR_start %>% type.convert) > (vector_query_VSR_end %>% type.convert))) {
warning("Error: Please ensure that all the start co-ordinates are not greater than your end co-ordinates")
return("triage fail")
}
message("triage successful")
return("triage successful")
}
# SHINY: ALTERNATIVE FUNCTION TO SCREEN INPUT COORDINATES
## based on IGV behaviour.
parse_input_coordinates <- function(input_coordinates, vector_of_expected_chromosomes) {
# DEBUG ###
# vector_input_coordinates <- c(
#     "16:89740100-89740803:8",
#     "16:89738975-89739477:+",
#     "16:89739267-89739993:*",
#     "16:89739290-89739477:0",
#     "16:89739554-89739993:.",
#     "8:89738975-89739137",
#     "89738975-89739132",
#     "16:89738975-89739128:-",
#     "16:89738709:89738881"
# )
# vector_input_coordinates <- c(
#     "1:2-3:+"
# )
# expect_stranded <- TRUE
# tibble_gtf_table <- tibble_ref_gtf
###########
# split into vector of chr start end strand.
vector_chr_start_end_strand <- input_coordinates %>% trimws() %>% gsub(pattern = "[^0-9]", replacement = " ") %>% stringr::str_squish() %>% strsplit(split = " ") %>% unlist %>% type.convert
# if length is 2, then it's a single nt. do a +/- 50nt window
if (vector_chr_start_end_strand %>% length == 2) {
output <- c(vector_chr_start_end_strand[1], vector_chr_start_end_strand[2] - 50, vector_chr_start_end_strand[2] + 50)
# if length is 3, then it's a geniune range.
} else if (vector_chr_start_end_strand %>% length == 3) {
output <- c(vector_chr_start_end_strand[1], min(vector_chr_start_end_strand[2], vector_chr_start_end_strand[3]), max(vector_chr_start_end_strand[2], vector_chr_start_end_strand[3]))
} else if (vector_chr_start_end_strand %>% length == 4) {
output <- c(vector_chr_start_end_strand[1], min(vector_chr_start_end_strand[2], vector_chr_start_end_strand[3]), max(vector_chr_start_end_strand[2], vector_chr_start_end_strand[3]))
} else {
output <- "non_coord"
}
return(output)
}
### SHINY ####
## having determined the plot window, calculate distances to every exon in the plot range
list_distance_annotation_data_flattened <- purrr::pmap(
.l = list(
"a1" = global_list_tibbles_track_features_visible_flattened_1,
"a2" = names(global_list_tibbles_track_features_visible_flattened_1),
"a3" = global_list_tibbles_track_features_all_flattened_1
),
.f = function(a1, a2, a3) {
# DEBUG ###
# a1 <- global_list_tibbles_track_features_visible_flattened_1[[1]]
# a2 <- names(global_list_tibbles_track_features_visible_flattened_1)[[1]]
# a3 <- global_list_tibbles_track_features_all_flattened_1[[1]]
# selected_user_range_chr <- global_selected_user_range_chr
# selected_user_range_start <- global_selected_user_range_start
# selected_user_range_end <- global_selected_user_range_end
###########
# determine visible transcript ids overlapped by user range
tibble_ref_transcripts_overlapped_by_user_query <- extract_overlapping_features(query_chr = selected_user_range_chr, query_start = selected_user_range_start, query_end = selected_user_range_end, query_strand = "*", tibble_gtf_table = a1, return_type = if (grepl(x = a2, pattern = "Reference protein") == TRUE) {"exon"} else {"transcript"})
print("tibble_ref_transcripts_overlapped_by_user_query")
print(tibble_ref_transcripts_overlapped_by_user_query)
# check if the selected transcript overlaps a ref transcript
if (tibble_ref_transcripts_overlapped_by_user_query %>% nrow > 0) {
tibble_all_exons_of_overlapped_parent_transcript <- a3[which(a3$type == "exon" & a3$transcript_id %in% (tibble_ref_transcripts_overlapped_by_user_query$transcript_id %>% unique)), ]
print("tibble_all_exons_of_overlapped_parent_transcript")
print(tibble_all_exons_of_overlapped_parent_transcript)
if (grepl(x = a2, pattern = "Reference protein") == TRUE) {
tibble_distance_annotations_based_on_user_query <- purrr::map2(
# overlapping transcript entries
.x = tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id),
# exons belonging to the transcript
.y = tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(protein_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$protein_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% purrr::map(~.x$protein_id %>% unique) %>% unlist],
.f = function(a1, a2) {
# DEBUG ###
# a1 <- tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% .[[2]]
# a2 <- tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(protein_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$protein_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% purrr::map(~.x$protein_id %>% unique) %>% unlist] %>% .[[2]]
###########
vector_all_ref_vertices <- a2[, c("start", "end")] %>% unlist %>% sort
# strategy: grow left and right ends of the user vertices until it touches a vertex.
left_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_start] %>% max
right_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_start] %>% min
left_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_end] %>% max
right_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_end] %>% min
tibble_vertices_with_distances <- tibble(
"protein_id" = a1$protein_id %>% unique,
"ref_vertex" = c(left_ref_vertex_grown_from_user_query_start, right_ref_vertex_grown_from_user_query_start, left_ref_vertex_grown_from_user_query_end, right_ref_vertex_grown_from_user_query_end),
"query_vertex" = c(selected_user_range_start, selected_user_range_start, selected_user_range_end, selected_user_range_end)
) %>% dplyr::mutate("ref_vertex_minus_query_vertex" = `ref_vertex` - `query_vertex`)
# test for redundant overlapping distances. this happens when 1. both query ends find a ref transcript and 2. distance to left overlaps and/or distance to right overlaps.
if (left_ref_vertex_grown_from_user_query_end < selected_user_range_start) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == left_ref_vertex_grown_from_user_query_end & tibble_vertices_with_distances$query_vertex == selected_user_range_end), ]
}
if (right_ref_vertex_grown_from_user_query_start > selected_user_range_end) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == right_ref_vertex_grown_from_user_query_start & tibble_vertices_with_distances$query_vertex == selected_user_range_start), ]
}
return(tibble_vertices_with_distances)
} ) %>% dplyr::bind_rows() %>% unique
} else {
tibble_distance_annotations_based_on_user_query <- purrr::map2(
# overlapping transcript entries
.x = tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id),
# exons belonging to the transcript
.y = tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% purrr::map(~.x$transcript_id %>% unique) %>% unlist],
.f = function(a1, a2) {
# DEBUG ###
# a1 <- tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% .[[2]]
# a2 <- tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% purrr::map(~.x$transcript_id %>% unique) %>% unlist] %>% .[[2]]
###########
vector_all_ref_vertices <- a2[, c("start", "end")] %>% unlist %>% sort
# strategy: grow left and right ends of the user vertices until it touches a vertex.
left_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_start] %>% max
right_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_start] %>% min
left_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_end] %>% max
right_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_end] %>% min
tibble_vertices_with_distances <- tibble(
"transcript_id" = a1$transcript_id %>% unique,
"ref_vertex" = c(left_ref_vertex_grown_from_user_query_start, right_ref_vertex_grown_from_user_query_start, left_ref_vertex_grown_from_user_query_end, right_ref_vertex_grown_from_user_query_end),
"query_vertex" = c(selected_user_range_start, selected_user_range_start, selected_user_range_end, selected_user_range_end)
) %>% dplyr::mutate("ref_vertex_minus_query_vertex" = `ref_vertex` - `query_vertex`)
# test for redundant overlapping distances. this happens when 1. both query ends find a ref transcript and 2. distance to left overlaps and/or distance to right overlaps.
if (left_ref_vertex_grown_from_user_query_end < selected_user_range_start) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == left_ref_vertex_grown_from_user_query_end & tibble_vertices_with_distances$query_vertex == selected_user_range_end), ]
}
if (right_ref_vertex_grown_from_user_query_start > selected_user_range_end) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == right_ref_vertex_grown_from_user_query_start & tibble_vertices_with_distances$query_vertex == selected_user_range_start), ]
}
return(tibble_vertices_with_distances)
} ) %>% dplyr::bind_rows() %>% unique
}
# make the distances directional
tibble_distance_annotations_based_on_user_query <- tibble_distance_annotations_based_on_user_query %>%
dplyr::mutate("ref_vertex_minus_query_vertex" = purrr::map(.x = `ref_vertex_minus_query_vertex`, .f = function(x) {
if (x < 0) {
return(paste(abs(x), ">", sep = ""))
} else if (x > 0) {
return(paste("<", abs(x), sep = ""))
} else {
return(x)
}
} ) %>% unlist  )
tibble_distance_annotations_based_on_user_query$panel <- a2
} else {
tibble_distance_annotations_based_on_user_query <- tibble()
tibble_all_exons_of_overlapped_parent_transcript <- tibble()
}
# invoke tolerances
# tibble_selected_range_measurement_against_reference[abs(tibble_selected_range_measurement_against_reference$distance_to_ref) <= 1, "distance_to_ref"] <- 0
##########
return(
list(
"tibble_distance_annotations_based_on_user_query" = tibble_distance_annotations_based_on_user_query,
"tibble_all_exons_of_overlapped_parent_transcript" = tibble_all_exons_of_overlapped_parent_transcript
)
)
} )
selected_user_range_chr <- global_selected_user_range_chr
selected_user_range_start <- global_selected_user_range_start
selected_user_range_end <- global_selected_user_range_end
## having determined the plot window, calculate distances to every exon in the plot range
list_distance_annotation_data_flattened <- purrr::pmap(
.l = list(
"a1" = global_list_tibbles_track_features_visible_flattened_1,
"a2" = names(global_list_tibbles_track_features_visible_flattened_1),
"a3" = global_list_tibbles_track_features_all_flattened_1
),
.f = function(a1, a2, a3) {
# DEBUG ###
# a1 <- global_list_tibbles_track_features_visible_flattened_1[[1]]
# a2 <- names(global_list_tibbles_track_features_visible_flattened_1)[[1]]
# a3 <- global_list_tibbles_track_features_all_flattened_1[[1]]
# selected_user_range_chr <- global_selected_user_range_chr
# selected_user_range_start <- global_selected_user_range_start
# selected_user_range_end <- global_selected_user_range_end
###########
# determine visible transcript ids overlapped by user range
tibble_ref_transcripts_overlapped_by_user_query <- extract_overlapping_features(query_chr = selected_user_range_chr, query_start = selected_user_range_start, query_end = selected_user_range_end, query_strand = "*", tibble_gtf_table = a1, return_type = if (grepl(x = a2, pattern = "Reference protein") == TRUE) {"exon"} else {"transcript"})
print("tibble_ref_transcripts_overlapped_by_user_query")
print(tibble_ref_transcripts_overlapped_by_user_query)
# check if the selected transcript overlaps a ref transcript
if (tibble_ref_transcripts_overlapped_by_user_query %>% nrow > 0) {
tibble_all_exons_of_overlapped_parent_transcript <- a3[which(a3$type == "exon" & a3$transcript_id %in% (tibble_ref_transcripts_overlapped_by_user_query$transcript_id %>% unique)), ]
print("tibble_all_exons_of_overlapped_parent_transcript")
print(tibble_all_exons_of_overlapped_parent_transcript)
if (grepl(x = a2, pattern = "Reference protein") == TRUE) {
tibble_distance_annotations_based_on_user_query <- purrr::map2(
# overlapping transcript entries
.x = tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id),
# exons belonging to the transcript
.y = tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(protein_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$protein_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% purrr::map(~.x$protein_id %>% unique) %>% unlist],
.f = function(a1, a2) {
# DEBUG ###
# a1 <- tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% .[[2]]
# a2 <- tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(protein_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$protein_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(protein_id) %>% purrr::map(~.x$protein_id %>% unique) %>% unlist] %>% .[[2]]
###########
vector_all_ref_vertices <- a2[, c("start", "end")] %>% unlist %>% sort
# strategy: grow left and right ends of the user vertices until it touches a vertex.
left_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_start] %>% max
right_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_start] %>% min
left_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_end] %>% max
right_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_end] %>% min
tibble_vertices_with_distances <- tibble(
"protein_id" = a1$protein_id %>% unique,
"ref_vertex" = c(left_ref_vertex_grown_from_user_query_start, right_ref_vertex_grown_from_user_query_start, left_ref_vertex_grown_from_user_query_end, right_ref_vertex_grown_from_user_query_end),
"query_vertex" = c(selected_user_range_start, selected_user_range_start, selected_user_range_end, selected_user_range_end)
) %>% dplyr::mutate("ref_vertex_minus_query_vertex" = `ref_vertex` - `query_vertex`)
# test for redundant overlapping distances. this happens when 1. both query ends find a ref transcript and 2. distance to left overlaps and/or distance to right overlaps.
if (left_ref_vertex_grown_from_user_query_end < selected_user_range_start) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == left_ref_vertex_grown_from_user_query_end & tibble_vertices_with_distances$query_vertex == selected_user_range_end), ]
}
if (right_ref_vertex_grown_from_user_query_start > selected_user_range_end) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == right_ref_vertex_grown_from_user_query_start & tibble_vertices_with_distances$query_vertex == selected_user_range_start), ]
}
return(tibble_vertices_with_distances)
} ) %>% dplyr::bind_rows() %>% unique
} else {
tibble_distance_annotations_based_on_user_query <- purrr::map2(
# overlapping transcript entries
.x = tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id),
# exons belonging to the transcript
.y = tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% purrr::map(~.x$transcript_id %>% unique) %>% unlist],
.f = function(a1, a2) {
# DEBUG ###
# a1 <- tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% .[[2]]
# a2 <- tibble_all_exons_of_overlapped_parent_transcript %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist) %>% .[tibble_ref_transcripts_overlapped_by_user_query %>% dplyr::group_split(transcript_id) %>% purrr::map(~.x$transcript_id %>% unique) %>% unlist] %>% .[[2]]
###########
vector_all_ref_vertices <- a2[, c("start", "end")] %>% unlist %>% sort
# strategy: grow left and right ends of the user vertices until it touches a vertex.
left_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_start] %>% max
right_ref_vertex_grown_from_user_query_start <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_start] %>% min
left_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices <= selected_user_range_end] %>% max
right_ref_vertex_grown_from_user_query_end <- vector_all_ref_vertices[vector_all_ref_vertices >= selected_user_range_end] %>% min
tibble_vertices_with_distances <- tibble(
"transcript_id" = a1$transcript_id %>% unique,
"ref_vertex" = c(left_ref_vertex_grown_from_user_query_start, right_ref_vertex_grown_from_user_query_start, left_ref_vertex_grown_from_user_query_end, right_ref_vertex_grown_from_user_query_end),
"query_vertex" = c(selected_user_range_start, selected_user_range_start, selected_user_range_end, selected_user_range_end)
) %>% dplyr::mutate("ref_vertex_minus_query_vertex" = `ref_vertex` - `query_vertex`)
# test for redundant overlapping distances. this happens when 1. both query ends find a ref transcript and 2. distance to left overlaps and/or distance to right overlaps.
if (left_ref_vertex_grown_from_user_query_end < selected_user_range_start) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == left_ref_vertex_grown_from_user_query_end & tibble_vertices_with_distances$query_vertex == selected_user_range_end), ]
}
if (right_ref_vertex_grown_from_user_query_start > selected_user_range_end) {
tibble_vertices_with_distances <- tibble_vertices_with_distances[!(tibble_vertices_with_distances$ref_vertex == right_ref_vertex_grown_from_user_query_start & tibble_vertices_with_distances$query_vertex == selected_user_range_start), ]
}
return(tibble_vertices_with_distances)
} ) %>% dplyr::bind_rows() %>% unique
}
# make the distances directional
tibble_distance_annotations_based_on_user_query <- tibble_distance_annotations_based_on_user_query %>%
dplyr::mutate("ref_vertex_minus_query_vertex" = purrr::map(.x = `ref_vertex_minus_query_vertex`, .f = function(x) {
if (x < 0) {
return(paste(abs(x), ">", sep = ""))
} else if (x > 0) {
return(paste("<", abs(x), sep = ""))
} else {
return(x)
}
} ) %>% unlist  )
tibble_distance_annotations_based_on_user_query$panel <- a2
} else {
tibble_distance_annotations_based_on_user_query <- tibble()
tibble_all_exons_of_overlapped_parent_transcript <- tibble()
}
# invoke tolerances
# tibble_selected_range_measurement_against_reference[abs(tibble_selected_range_measurement_against_reference$distance_to_ref) <= 1, "distance_to_ref"] <- 0
##########
return(
list(
"tibble_distance_annotations_based_on_user_query" = tibble_distance_annotations_based_on_user_query,
"tibble_all_exons_of_overlapped_parent_transcript" = tibble_all_exons_of_overlapped_parent_transcript
)
)
} )
global_list_tibbles_track_features_visible
global_workshop_reactiveValues_annotation_files_selected
list_tibbles_track_features_visible_flattened
global_list_tibbles_track_features_visible_flattened_1
global_list_tibbles_track_features_all_flattened_1
global_list_tibbles_track_features_visible
global_list_tibbles_track_features_visible_flattened_1
global_list_tibbles_track_features_all_flattened_1
list_tibbles_track_features_visible_flattened
list_tibbles_track_features_visible
global_workshop_reactiveValues_annotation_files_selected
global_list_tibbles_track_features_visible
global_workshop_reactiveValues_annotation_files_selected
global_list_tibbles_track_features_visible
global_list_tibbles_track_features_visible_flattened_1
global_list_tibbles_track_features_all_flattened_1
global_list_tibbles_track_features_visible_flattened_1 %>% names %>% gsub("^[^\\:]+\\: (.*)", replacement = "\\1")
global_list_tibbles_track_features_visible_flattened_1 %>% names %>% gsub(pattern = "^[^\\:]+\\: (.*)", replacement = "\\1")
list_tibbles_track_features_all_flattened[global_list_tibbles_track_features_visible_flattened_1 %>% names %>% gsub(pattern = "^[^\\:]+\\: (.*)", replacement = "\\1")]
global_list_tibbles_track_features_all_flattened_1[global_list_tibbles_track_features_visible_flattened_1 %>% names %>% gsub(pattern = "^[^\\:]+\\: (.*)", replacement = "\\1")]
global_list_tibbles_track_features_all_flattened_1
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
