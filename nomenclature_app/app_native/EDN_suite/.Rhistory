if (strand == "+") {
exon_start_AA_position <- ceiling((ES - 1 - frame) / 3) + 1
exon_end_AA_position <- floor((EE - 1 - frame) / 3)
} else if (strand == "-") {
exon_start_AA_position <- ceiling((TL - EE - frame) / 3) + 1
exon_end_AA_position <- floor((TL - ES - frame) / 3)
}
return(list("exon_start_AA_position" = exon_start_AA_position, "exon_end_AA_position" = exon_end_AA_position))
}
# FUNCTIONS to test if the left/right side of stop codons in an exon are translatable or not. (i.e. whether uORF or dORF exists or not)
## NOTE: by definition, the first AA of the uORF is the first nucleotide in the window.
find_valid_uORF <- function(list) {
AA_sequence <- list[[1]] %>% unlist
window_start_AA_position <- list[[2]] %>% paste %>% as.numeric
window_end_AA_position <- list[[3]] %>% paste %>% as.numeric
junction_AA_position <- list[[4]] %>% paste %>% as.numeric
validity_test <- stringr::str_detect(AA_sequence[1:(window_start_AA_position - 1)] %>% rev %>% paste(collapse = ""), "^[^\\*]+M|^[^\\*]+$")
exonic_uORF_sequence <- AA_sequence[window_start_AA_position:window_end_AA_position] %>% paste(collapse = "") %>% strsplit(., split = "\\*") %>% unlist %>% first
# if there is indeed a valid uORF then translate the first part within the exon
if (validity_test == TRUE & nchar(exonic_uORF_sequence) > (junction_AA_position - window_start_AA_position + 1)) {
return(exonic_uORF_sequence)
} else {
return("NONE_VALID")
}
}
## NOTE: by definition, the first AA of the dORF is the last nucleotide in the window - dORF AA length + 1!!
find_valid_dORF <- function(list) {
AA_sequence <- list[[1]] %>% unlist
window_start_AA_position <- list[[2]] %>% paste %>% as.numeric
window_end_AA_position <- list[[3]] %>% paste %>% as.numeric
junction_AA_position <- list[[4]] %>% paste %>% as.numeric
validity_test <- stringr::str_detect(AA_sequence[window_start_AA_position:window_end_AA_position] %>% rev %>% paste(collapse = ""), "^[^\\*]+M|^[^\\*]+$")
exonic_dORF_sequence <- AA_sequence[window_start_AA_position:window_end_AA_position] %>% paste(collapse = "") %>% strsplit(., split = "\\*") %>% unlist %>% last
# if there is indeed a valid dORF then translate the first part within the exon
if (validity_test == TRUE & nchar(exonic_dORF_sequence) > (junction_AA_position - window_start_AA_position + 1)) {
return(exonic_dORF_sequence)
} else {
return("NONE_VALID")
}
}
# END find_valid_uORF() and find_valid_dORF()
# MAIN FUNCTION TO DO 3FT OF JUNCTIONS
# Behaviour: for each junction, look up every single transcript that it's associated with. Translate in three frames and find which frame can validly translate the exon.
# These transcripts are matched according to both reference and reconstructed GTF.
# The smallest protein in humans is 44 AA so the smallest valid translatable nucleotide length is 132 nt.
# Translated region included in the upstream/downstream window must cross the splice junction.
# END FUNCTIONS #####################################################################################################
#####################################################################################################################
#####################################################################################################################
cat("# BEGIN EXECUTION #################################\n")
vector_ref_genome_paths_by_chr <- paste(reference_genome_fasta_dir, list.files(reference_genome_fasta_dir)[list.files(reference_genome_fasta_dir) %>% grep(., pattern = ".*.fa$")], sep = "")
# reference_genome_fasta <- seqinr::read.fasta(file = reference_genome_fasta_path, forceDNAtolower = FALSE)
# total_peptide_window_size <- upstream_window_size + downstream_window_size
# cat("total translation window size:", total_peptide_window_size, "\n")
tibble_reconstructed_gtf <- rtracklayer::import(reconstructed_gtf_path) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) %>% type_convert
# list-ify the recon GTF by chromosome
list_recon_gtf_subset_by_chr <- tibble_reconstructed_gtf %>% dplyr::group_split(seqnames)
names(list_recon_gtf_subset_by_chr) <- list_recon_gtf_subset_by_chr %>% purrr::map(.f = ~.x$seqnames %>% unique) %>% unlist
# filter chr for only user specified chr
list_recon_gtf_subset_by_chr <- list_recon_gtf_subset_by_chr[chr_to_run]
cat("GTF importing done\n")
tibble_junction_table <- read.delim(junction_table_path, sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% unique
# %>% .[sample(1:nrow(.), size = 100),]
# list-ify the junction table by chromosome
list_junction_table_by_chr <- tibble_junction_table %>% dplyr::group_split(chr)
# filter chr for only user specified chr
names(list_junction_table_by_chr) <- list_junction_table_by_chr %>% purrr::map(~.$chr %>% unique) %>% unlist
# subset the recon GTF and junction table by chromosomes in common so that we can map2 over them
vector_chr_in_common <- intersect(names(list_recon_gtf_subset_by_chr), names(list_junction_table_by_chr))
list_junction_table_by_chr <- list_junction_table_by_chr[vector_chr_in_common]
list_recon_gtf_subset_by_chr <- list_recon_gtf_subset_by_chr[vector_chr_in_common]
cat("get positions of the vector where the path of the ref. genome fasta\n")
vector_ref_genome_paths_by_chr_position <- vector_chr_in_common %>% purrr::map(.f = function(a1) {
# DEBUG ###
# a1 <- 1
###########
# cat(a1, "\n")
ref_genome_path_by_chr_position <- grep(x = vector_ref_genome_paths_by_chr, pattern = paste("(\\D|^)", a1, ".fa$", sep = ""))
if (length(ref_genome_path_by_chr_position) != 1) {
stop("Something is wrong with the contents of the fasta file directory. Please check that it's structured in the desired format.")
} else {
return(ref_genome_path_by_chr_position)
}
} ) %>% unlist
# fetch full path of ref. genome fasta
vector_ref_genome_fasta_path <- paste(vector_ref_genome_paths_by_chr[vector_ref_genome_paths_by_chr_position])
plan(list(tweak(callr, workers = 96),
tweak(sequential)))
purrr::pmap(
.l = list(
# "a1" = list_junction_table_by_chr,
# "a2" = list_recon_gtf_subset_by_chr,
"a3" = vector_ref_genome_fasta_path[c(2:4, 9:10, 16:18)],
"a4" = vector_chr_in_common[c(2:4, 9:10, 16:18)]
),
.f = function(a3, a4) {
# DEBUG ###
# a1 <- list_junction_table_by_chr[[1]]
# a2 <- list_recon_gtf_subset_by_chr[[1]]
# a3 <- vector_ref_genome_fasta_path[[20]]
# a4 <- chr_to_run[[20]]
#
# plan(list(tweak(callr, workers = L2_ncores),
#           tweak(sequential)))
###########
# Strategy: match junctions to transcripts with directly flanking exons
# add artificial entry alongside the parent transcript entries indicating the junction
# later, we use the junction coords to determine the start/end coords according to the specified window using the transcript topology.
cat("get junction-flanking exon matches from the GTF\n")
furrr::future_map(
.x = 1:L2_ncores,
.f = function(L2_index) {
# DEBUG ###
# L2_index <- (1:L2_ncores) %>% .[[1]]
###########
# cat(L2_index, "\n")
# import stuff
load(file = paste(tempdir, "list_junction_table_by_chr_chr_", a4, "_part_", L2_index, ".Rlist", sep = ""))
load(file = paste(tempdir, "list_recon_gtf_subset_by_chr_chr_", a4, ".tibble", sep = ""))
cat("temporary allocation to ref genome fasta list\n")
reference_genome_fasta_chr_temp <- seqinr::read.fasta(file = a3, forceDNAtolower = FALSE)
# execute pipeline
list_3FT_result_temp <- purrr::imap(
.x = a1_chunk,
.f = function(b1, b2) {
# DEBUG ###
# b1 <- a1_chunk[[1]]
###########
# cat(b2, "\n")
matching_GTF_entries <- extract_junction.flanking.exons(query_chr = b1$chr %>% type.convert,
query_start = b1$start %>% type.convert,
query_end = b1$end %>% type.convert,
query_strand = b1$strand %>% type.convert,
tibble_gtf_table = a2,
tolerance_left = 1,
tolerance_right = 1,
tolerance_inside = 1,
tolerance_outside = 0,
match_consecutive = TRUE,
return_type = "exon")
matching_GTF_entries_with_artificial_entry <- purrr::map(.x = matching_GTF_entries, .f = function(c1) {
# DEBUG ###
# c1 <- matching_GTF_entries[[1]]
###########
# splice in the artificial overlapping exon element using the flanking exons.
# this entry describes the matched junction in the GTF, which is practically a magnetisation.
# it will be a single GTF row, with median exon number, spanning the intron junction of the matched transcript.
list_matched_GTF_entries_with_junction_specification <- purrr::splice(c1,
"junction_specifications" = c1$matched_flanking_exons %>% .[1, ] %>% dplyr::select(., -start, -end, -width, -exon_number) %>% add_column("start" = (c1$matched_flanking_exons %>% .[1, "end"] %>% paste %>% as.numeric + 1), "end" = (c1$matched_flanking_exons %>% .[2, "start"] %>% paste %>% as.numeric - 1), "exon_number" = mean(c1$matched_flanking_exons %>% .$exon_number %>% as.numeric)) %>% add_column("width" = .$end %>% as.numeric - .$start %>% as.numeric + 1))
# if intronic, then splice in the intronic region into the parent transcript.
if (grepl(x = b1$splicemode, pattern = intron_retention_string) == TRUE) {
list_matched_GTF_entries_with_junction_specification$parent_transcript <- dplyr::bind_rows(list_matched_GTF_entries_with_junction_specification$parent_transcript,
list_matched_GTF_entries_with_junction_specification$junction_specifications) %>% dplyr::arrange(exon_number)
}
return(list_matched_GTF_entries_with_junction_specification)
} ) # L3
final_identifier <- if (b1$custom_identifier %>% is.na != TRUE) {b1$custom_identifier
} else {
paste(source_tag, "_junction_", b1$chr, ":", b1$start %>% type.convert, "-", b1$end%>% type.convert,
if ((b1$strand == "+" | b1$strand == "-") & b1$strand %>% is.na != TRUE) {
paste(":", b1$strand, sep = "")
} else {
""
}, sep = "")
}
# create fasta header
fasta_header <- paste(source_tag,
"|",
final_identifier,
"|",
matching_GTF_entries %>% names %>% paste(collapse = ","),
" OS=",
b1$organism,
" GN=",
b1$gene_name, sep = "")
# update main list ###
b1 <- purrr::splice(
b1 %>% flatten,
"matching_GTF_entries" = matching_GTF_entries_with_artificial_entry %>% list,
"final_identifier" = final_identifier %>% list,
"fasta_header" = fasta_header %>% list
)
# extract the magnetised junction start and end coords.
result <- list("3FT_info" = purrr::map(.x = b1$matching_GTF_entries, .f = ~list(
"matched_junction_chr" = .x$junction_specifications$seqnames %>% paste,
"matched_junction_start" = .x$junction_specifications$start %>% paste,
"matched_junction_end" = .x$junction_specifications$end %>% paste,
"matched_junction_strand" = .x$junction_specifications$strand %>% paste,
# generate vector of all nucleotide coors from $start to $end
"all_parent_transcript_coords" = purrr::map2(.x = .x[["parent_transcript"]]$start, .y = .x[["parent_transcript"]]$end, .f = ~.x:.y) %>% unlist %>% sort) %>%
# add in the TRANSCRIPT-RELATIVE POSITIONS of the JUNCTION ACCORDING TO THE SPECIFIED WINDOW
purrr::splice(.,
"translation_window_start_transcript.relative" = if (.$matched_junction_strand == "+") {
max(1, which(.$all_parent_transcript_coords == (.$matched_junction_start %>% as.numeric - 1)) - upstream_window_size + 1)
} else if (.$matched_junction_strand == "-") {
max(1, which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_end %>% as.numeric + 1)) - upstream_window_size + 1)
},
"translation_window_end_transcript.relative" = if (.$matched_junction_strand == "+") {
min(length(.$all_parent_transcript_coords), which(.$all_parent_transcript_coords == (.$matched_junction_end %>% as.numeric + 1)) + downstream_window_size - 1)
} else if (.$matched_junction_strand == "-") {
min(length(.$all_parent_transcript_coords), which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_start %>% as.numeric - 1)) + downstream_window_size - 1)
},
"last_nt_before_splice_junction_transcript_relative" = if (.$matched_junction_strand == "+") {
which(.$all_parent_transcript_coords == (.$matched_junction_start %>% as.numeric - 1))
} else if (.$matched_junction_strand == "-") {
which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_end %>% as.numeric + 1))
},
"first_nt_after_splice_junction_transcript_relative" = if (.$matched_junction_strand == "+") {
which(.$all_parent_transcript_coords == (.$matched_junction_end %>% as.numeric + 1))
} else if (.$matched_junction_strand == "-") {
which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_start %>% as.numeric - 1))
},
# add in all the nucleotide coords of the PARENT transcript
"parent_transcript_forward_nucleotides" = reference_genome_fasta_chr_temp[[b1$chr %>% paste]][.$all_parent_transcript_coords])))
# update L2 list
b1 <- splice(
b1,
result
)
updated_3FT_info <- purrr::imap(
.x = b1$`3FT_info`,
.f = function(c1, c2) {
# DEBUG ###
# c1 <- b1$`3FT_info`$MSTRG.241.10
###########
# cat("now processing entry number", c2, "/", length(list_matched_coords_temp), "\n")
# three frame translation, add translation frame-relative coordinates of window start and end
L3_result <- purrr::splice(c1, nt.sequence_strand_threeframetranslate(vector_forward_nucleotides = c1$parent_transcript_forward_nucleotides, strand = c1$matched_junction_strand),
"window_start_AA_position_frame_0" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"window_start_AA_position_frame_1" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"window_start_AA_position_frame_2" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position,
"window_end_AA_position_frame_0" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_end_AA_position,
"window_end_AA_position_frame_1" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_end_AA_position,
"window_end_AA_position_frame_2" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_end_AA_position,
"junction_AA_position_frame_0_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"junction_AA_position_frame_1_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"junction_AA_position_frame_2_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position,
"junction_AA_position_frame_0_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"junction_AA_position_frame_1_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"junction_AA_position_frame_2_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position) %>%
# check for upstream ORF as well as downstream ORF (starting from within the exon) by seeing if you reverse the AA sequence, do you see a methionine always before the first stop codon
# will enter logical indicating whether the exon has a valid uORF or not in the given translation frame
purrr::splice(
# uORF
"uORF_valid_frame_0" = find_valid_uORF(.[c("translation_frame_0", "window_start_AA_position_frame_0", "window_end_AA_position_frame_0", "junction_AA_position_frame_0_upstream")]),
"uORF_valid_frame_1" = find_valid_uORF(.[c("translation_frame_1", "window_start_AA_position_frame_1", "window_end_AA_position_frame_1", "junction_AA_position_frame_1_upstream")]),
"uORF_valid_frame_2" = find_valid_uORF(.[c("translation_frame_2", "window_start_AA_position_frame_2", "window_end_AA_position_frame_2", "junction_AA_position_frame_2_upstream")]),
# dORF
"dORF_valid_frame_0" = find_valid_dORF(.[c("translation_frame_0", "window_start_AA_position_frame_0", "window_end_AA_position_frame_0", "junction_AA_position_frame_0_downstream")]),
"dORF_valid_frame_1" = find_valid_dORF(.[c("translation_frame_1", "window_start_AA_position_frame_1", "window_end_AA_position_frame_1", "junction_AA_position_frame_1_downstream")]),
"dORF_valid_frame_2" = find_valid_dORF(.[c("translation_frame_2", "window_start_AA_position_frame_2", "window_end_AA_position_frame_2", "junction_AA_position_frame_2_downstream")])
) %>%
# collapse the forward nucleotide and 3FT sequences into string from a vector
purrr::modify_at(.x = ., .at = c("parent_transcript_forward_nucleotides", "translation_frame_0", "translation_frame_1", "translation_frame_2"), .f = ~.x %>% paste(collapse = "")) %>%
# collapse the parent transcript coords into string from a vector
purrr::modify_at(.x = ., .at = c("all_parent_transcript_coords"), .f = ~.x %>% paste(collapse = ","))
return(L3_result[!names(L3_result) %in% c("parent_transcript_forward_nucleotides", "all_parent_transcript_coords", "translation_frame_0", "translation_frame_1", "translation_frame_2")])
} ) # L3
# update L2 list
b1$`3FT_info` <- updated_3FT_info
return(b1)
} ) # L2
# flatten and distribute the fasta header into all of its child 3FT results
list_3FT_result_unnest_temp <- list_3FT_result_temp %>% purrr::discard(.p = ~.x %>% length == 0) %>% purrr::discard(.p = ~.x$`3FT_info` %>% length == 0) %>% purrr::map(.x = list_3FT_result_temp, .f = ~purrr::cross2(.x[c("chr", "start", "end", "strand", "gene_name", "fasta_header", "final_identifier", "splicemode")] %>% list, .x$`3FT_info`)) %>% flatten %>% purrr::map(.f = ~.x %>% flatten)
# rearrange info into a tibble. one translation frame per row. %>% flatten
# first, tibblise the translation frame elements of the list, then as_tibble the rest.
cat("rearrange the three-frame translate results into a tibble\n")
list_3FT_result_unnest_temp_2 <- purrr::imap(
.x = list_3FT_result_unnest_temp,
.f = function(b1, b2) {
# DEBUG #####
# b1 <- list_3FT_result_unnest_temp[[1]]
#############
# cat("now processing entry number", b2, "/", length(list_3FT_result_unnest_temp), "\n")
# define the element indices inside the list which contains info for each frame.
element.indices_frame_info <- grep(x = names(b1), pattern = "frame_\\d")
# element indices containing the virtual peptides
element.indices_virtual_peptides <- grep(x = names(b1), pattern = "translation_frame_\\d")
# element indices of the frame info but not the virtual peptides
element.indices_not_virtual_peptides <- setdiff(element.indices_frame_info, element.indices_virtual_peptides)
# make the tibble of the virtual peptides first.
tibble_frame_info <- b1[c("translation_frame_0", "translation_frame_1", "translation_frame_2")] %>% as.data.frame %>% t %>% as_tibble(rownames = "translation_frame", .name_repair = "unique")
colnames(tibble_frame_info)[2] <- "parent_transcript_virtual_peptide_sequence"
# tidy the frame number
tibble_frame_info[, "translation_frame"] <- gsub(x = tibble_frame_info$translation_frame, pattern = "translation_frame_", replacement = "")
# then make the tibble of the rest. join it onto the existing table
tibble_frame_info_temp <- b1[element.indices_not_virtual_peptides] %>% as.data.frame %>% t %>% matrix(nrow = 3, byrow = FALSE, dimnames = list(0:2, gsub(x = names(b1[element.indices_not_virtual_peptides]), pattern = "(_frame_\\d)", replacement = "") %>% unique)) %>% as_tibble(rownames = "translation_frame", .name_repair = "unique")
# table join
tibble_frame_info <- dplyr::full_join(tibble_frame_info, tibble_frame_info_temp, by = "translation_frame")
# finally join the tibblised parts of the list to the non-tibblised.
list_half_tibblised <- splice("frame_info" = tibble_frame_info, b1[-element.indices_frame_info])
fully_tibblised_list <- list_half_tibblised %>% flatten %>% as_tibble
return(fully_tibblised_list)
} ) # L2
save(list_3FT_result_unnest_temp_2, file = paste(tempdir, "list_3FT_result_unnest_temp_2_chr_", a4, "_part_", L2_index, ".Rlist", sep = ""), compress = FALSE)
return(NULL)
} ) # L1a
return(NULL)
}, .progress = TRUE ) # L1
purrr::pmap(
.l = list(
# "a1" = list_junction_table_by_chr,
# "a2" = list_recon_gtf_subset_by_chr,
"a3" = vector_ref_genome_fasta_path[c(2:4, 9:10, 16:18)],
"a4" = vector_chr_in_common[c(2:4, 9:10, 16:18)]
),
.f = function(a3, a4) {
# DEBUG ###
# a1 <- list_junction_table_by_chr[[1]]
# a2 <- list_recon_gtf_subset_by_chr[[1]]
# a3 <- vector_ref_genome_fasta_path[[20]]
# a4 <- chr_to_run[[20]]
#
# plan(list(tweak(callr, workers = L2_ncores),
#           tweak(sequential)))
###########
# Strategy: match junctions to transcripts with directly flanking exons
# add artificial entry alongside the parent transcript entries indicating the junction
# later, we use the junction coords to determine the start/end coords according to the specified window using the transcript topology.
cat("get junction-flanking exon matches from the GTF\n")
furrr::future_map(
.x = 1:L2_ncores,
.f = function(L2_index) {
# DEBUG ###
# L2_index <- (1:L2_ncores) %>% .[[1]]
###########
# cat(L2_index, "\n")
# import stuff
load(file = paste(tempdir, "list_junction_table_by_chr_chr_", a4, "_part_", L2_index, ".Rlist", sep = ""))
load(file = paste(tempdir, "list_recon_gtf_subset_by_chr_chr_", a4, ".tibble", sep = ""))
cat("temporary allocation to ref genome fasta list\n")
reference_genome_fasta_chr_temp <- seqinr::read.fasta(file = a3, forceDNAtolower = FALSE)
# execute pipeline
list_3FT_result_temp <- purrr::imap(
.x = a1_chunk,
.f = function(b1, b2) {
# DEBUG ###
# b1 <- a1_chunk[[1]]
###########
# cat(b2, "\n")
matching_GTF_entries <- extract_junction.flanking.exons(query_chr = b1$chr %>% type.convert,
query_start = b1$start %>% type.convert,
query_end = b1$end %>% type.convert,
query_strand = b1$strand %>% type.convert,
tibble_gtf_table = a2,
tolerance_left = 1,
tolerance_right = 1,
tolerance_inside = 1,
tolerance_outside = 0,
match_consecutive = TRUE,
return_type = "exon")
matching_GTF_entries_with_artificial_entry <- purrr::map(.x = matching_GTF_entries, .f = function(c1) {
# DEBUG ###
# c1 <- matching_GTF_entries[[1]]
###########
# splice in the artificial overlapping exon element using the flanking exons.
# this entry describes the matched junction in the GTF, which is practically a magnetisation.
# it will be a single GTF row, with median exon number, spanning the intron junction of the matched transcript.
list_matched_GTF_entries_with_junction_specification <- purrr::splice(c1,
"junction_specifications" = c1$matched_flanking_exons %>% .[1, ] %>% dplyr::select(., -start, -end, -width, -exon_number) %>% add_column("start" = (c1$matched_flanking_exons %>% .[1, "end"] %>% paste %>% as.numeric + 1), "end" = (c1$matched_flanking_exons %>% .[2, "start"] %>% paste %>% as.numeric - 1), "exon_number" = mean(c1$matched_flanking_exons %>% .$exon_number %>% as.numeric)) %>% add_column("width" = .$end %>% as.numeric - .$start %>% as.numeric + 1))
# if intronic, then splice in the intronic region into the parent transcript.
if (grepl(x = b1$splicemode, pattern = intron_retention_string) == TRUE) {
list_matched_GTF_entries_with_junction_specification$parent_transcript <- dplyr::bind_rows(list_matched_GTF_entries_with_junction_specification$parent_transcript,
list_matched_GTF_entries_with_junction_specification$junction_specifications) %>% dplyr::arrange(exon_number)
}
return(list_matched_GTF_entries_with_junction_specification)
} ) # L3
final_identifier <- if (b1$custom_identifier %>% is.na != TRUE) {b1$custom_identifier
} else {
paste(source_tag, "_junction_", b1$chr, ":", b1$start %>% type.convert, "-", b1$end%>% type.convert,
if ((b1$strand == "+" | b1$strand == "-") & b1$strand %>% is.na != TRUE) {
paste(":", b1$strand, sep = "")
} else {
""
}, sep = "")
}
# create fasta header
fasta_header <- paste(source_tag,
"|",
final_identifier,
"|",
matching_GTF_entries %>% names %>% paste(collapse = ","),
" OS=",
b1$organism,
" GN=",
b1$gene_name, sep = "")
# update main list ###
b1 <- purrr::splice(
b1 %>% flatten,
"matching_GTF_entries" = matching_GTF_entries_with_artificial_entry %>% list,
"final_identifier" = final_identifier %>% list,
"fasta_header" = fasta_header %>% list
)
# extract the magnetised junction start and end coords.
result <- list("3FT_info" = purrr::map(.x = b1$matching_GTF_entries, .f = ~list(
"matched_junction_chr" = .x$junction_specifications$seqnames %>% paste,
"matched_junction_start" = .x$junction_specifications$start %>% paste,
"matched_junction_end" = .x$junction_specifications$end %>% paste,
"matched_junction_strand" = .x$junction_specifications$strand %>% paste,
# generate vector of all nucleotide coors from $start to $end
"all_parent_transcript_coords" = purrr::map2(.x = .x[["parent_transcript"]]$start, .y = .x[["parent_transcript"]]$end, .f = ~.x:.y) %>% unlist %>% sort) %>%
# add in the TRANSCRIPT-RELATIVE POSITIONS of the JUNCTION ACCORDING TO THE SPECIFIED WINDOW
purrr::splice(.,
"translation_window_start_transcript.relative" = if (.$matched_junction_strand == "+") {
max(1, which(.$all_parent_transcript_coords == (.$matched_junction_start %>% as.numeric - 1)) - upstream_window_size + 1)
} else if (.$matched_junction_strand == "-") {
max(1, which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_end %>% as.numeric + 1)) - upstream_window_size + 1)
},
"translation_window_end_transcript.relative" = if (.$matched_junction_strand == "+") {
min(length(.$all_parent_transcript_coords), which(.$all_parent_transcript_coords == (.$matched_junction_end %>% as.numeric + 1)) + downstream_window_size - 1)
} else if (.$matched_junction_strand == "-") {
min(length(.$all_parent_transcript_coords), which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_start %>% as.numeric - 1)) + downstream_window_size - 1)
},
"last_nt_before_splice_junction_transcript_relative" = if (.$matched_junction_strand == "+") {
which(.$all_parent_transcript_coords == (.$matched_junction_start %>% as.numeric - 1))
} else if (.$matched_junction_strand == "-") {
which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_end %>% as.numeric + 1))
},
"first_nt_after_splice_junction_transcript_relative" = if (.$matched_junction_strand == "+") {
which(.$all_parent_transcript_coords == (.$matched_junction_end %>% as.numeric + 1))
} else if (.$matched_junction_strand == "-") {
which(.$all_parent_transcript_coords %>% rev == (.$matched_junction_start %>% as.numeric - 1))
},
# add in all the nucleotide coords of the PARENT transcript
"parent_transcript_forward_nucleotides" = reference_genome_fasta_chr_temp[[b1$chr %>% paste]][.$all_parent_transcript_coords])))
# update L2 list
b1 <- splice(
b1,
result
)
updated_3FT_info <- purrr::imap(
.x = b1$`3FT_info`,
.f = function(c1, c2) {
# DEBUG ###
# c1 <- b1$`3FT_info`$MSTRG.241.10
###########
# cat("now processing entry number", c2, "/", length(list_matched_coords_temp), "\n")
# three frame translation, add translation frame-relative coordinates of window start and end
L3_result <- purrr::splice(c1, nt.sequence_strand_threeframetranslate(vector_forward_nucleotides = c1$parent_transcript_forward_nucleotides, strand = c1$matched_junction_strand),
"window_start_AA_position_frame_0" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"window_start_AA_position_frame_1" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"window_start_AA_position_frame_2" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position,
"window_end_AA_position_frame_0" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_end_AA_position,
"window_end_AA_position_frame_1" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_end_AA_position,
"window_end_AA_position_frame_2" = calculate_translation_frame_relative_start_end_position(ES = c1$translation_window_start_transcript.relative, EE = c1$translation_window_end_transcript.relative, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_end_AA_position,
"junction_AA_position_frame_0_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"junction_AA_position_frame_1_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"junction_AA_position_frame_2_upstream" = calculate_translation_frame_relative_start_end_position(ES = c1$last_nt_before_splice_junction_transcript_relative + 1, EE = c1$last_nt_before_splice_junction_transcript_relative + 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position,
"junction_AA_position_frame_0_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 0)$exon_start_AA_position,
"junction_AA_position_frame_1_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 1)$exon_start_AA_position,
"junction_AA_position_frame_2_downstream" = calculate_translation_frame_relative_start_end_position(ES = c1$first_nt_after_splice_junction_transcript_relative - 1, EE = c1$first_nt_after_splice_junction_transcript_relative - 1, TL = length(c1$all_parent_transcript_coords), strand = "+", frame = 2)$exon_start_AA_position) %>%
# check for upstream ORF as well as downstream ORF (starting from within the exon) by seeing if you reverse the AA sequence, do you see a methionine always before the first stop codon
# will enter logical indicating whether the exon has a valid uORF or not in the given translation frame
purrr::splice(
# uORF
"uORF_valid_frame_0" = find_valid_uORF(.[c("translation_frame_0", "window_start_AA_position_frame_0", "window_end_AA_position_frame_0", "junction_AA_position_frame_0_upstream")]),
"uORF_valid_frame_1" = find_valid_uORF(.[c("translation_frame_1", "window_start_AA_position_frame_1", "window_end_AA_position_frame_1", "junction_AA_position_frame_1_upstream")]),
"uORF_valid_frame_2" = find_valid_uORF(.[c("translation_frame_2", "window_start_AA_position_frame_2", "window_end_AA_position_frame_2", "junction_AA_position_frame_2_upstream")]),
# dORF
"dORF_valid_frame_0" = find_valid_dORF(.[c("translation_frame_0", "window_start_AA_position_frame_0", "window_end_AA_position_frame_0", "junction_AA_position_frame_0_downstream")]),
"dORF_valid_frame_1" = find_valid_dORF(.[c("translation_frame_1", "window_start_AA_position_frame_1", "window_end_AA_position_frame_1", "junction_AA_position_frame_1_downstream")]),
"dORF_valid_frame_2" = find_valid_dORF(.[c("translation_frame_2", "window_start_AA_position_frame_2", "window_end_AA_position_frame_2", "junction_AA_position_frame_2_downstream")])
) %>%
# collapse the forward nucleotide and 3FT sequences into string from a vector
purrr::modify_at(.x = ., .at = c("parent_transcript_forward_nucleotides", "translation_frame_0", "translation_frame_1", "translation_frame_2"), .f = ~.x %>% paste(collapse = "")) %>%
# collapse the parent transcript coords into string from a vector
purrr::modify_at(.x = ., .at = c("all_parent_transcript_coords"), .f = ~.x %>% paste(collapse = ","))
return(L3_result[!names(L3_result) %in% c("parent_transcript_forward_nucleotides", "all_parent_transcript_coords", "translation_frame_0", "translation_frame_1", "translation_frame_2")])
} ) # L3
# update L2 list
b1$`3FT_info` <- updated_3FT_info
return(b1)
} ) # L2
# flatten and distribute the fasta header into all of its child 3FT results
list_3FT_result_unnest_temp <- list_3FT_result_temp %>% purrr::discard(.p = ~.x %>% length == 0) %>% purrr::discard(.p = ~.x$`3FT_info` %>% length == 0) %>% purrr::map(.x = list_3FT_result_temp, .f = ~purrr::cross2(.x[c("chr", "start", "end", "strand", "gene_name", "fasta_header", "final_identifier", "splicemode")] %>% list, .x$`3FT_info`)) %>% flatten %>% purrr::map(.f = ~.x %>% flatten)
# rearrange info into a tibble. one translation frame per row. %>% flatten
# first, tibblise the translation frame elements of the list, then as_tibble the rest.
cat("rearrange the three-frame translate results into a tibble\n")
list_3FT_result_unnest_temp_2 <- purrr::imap(
.x = list_3FT_result_unnest_temp,
.f = function(b1, b2) {
# DEBUG #####
# b1 <- list_3FT_result_unnest_temp[[1]]
#############
# cat("now processing entry number", b2, "/", length(list_3FT_result_unnest_temp), "\n")
# define the element indices inside the list which contains info for each frame.
element.indices_frame_info <- grep(x = names(b1), pattern = "frame_\\d")
# element indices containing the virtual peptides
element.indices_virtual_peptides <- grep(x = names(b1), pattern = "translation_frame_\\d")
# element indices of the frame info but not the virtual peptides
element.indices_not_virtual_peptides <- setdiff(element.indices_frame_info, element.indices_virtual_peptides)
# make the tibble of the virtual peptides first.
tibble_frame_info <- b1[c("translation_frame_0", "translation_frame_1", "translation_frame_2")] %>% as.data.frame %>% t %>% as_tibble(rownames = "translation_frame", .name_repair = "unique")
colnames(tibble_frame_info)[2] <- "parent_transcript_virtual_peptide_sequence"
# tidy the frame number
tibble_frame_info[, "translation_frame"] <- gsub(x = tibble_frame_info$translation_frame, pattern = "translation_frame_", replacement = "")
# then make the tibble of the rest. join it onto the existing table
tibble_frame_info_temp <- b1[element.indices_not_virtual_peptides] %>% as.data.frame %>% t %>% matrix(nrow = 3, byrow = FALSE, dimnames = list(0:2, gsub(x = names(b1[element.indices_not_virtual_peptides]), pattern = "(_frame_\\d)", replacement = "") %>% unique)) %>% as_tibble(rownames = "translation_frame", .name_repair = "unique")
# table join
tibble_frame_info <- dplyr::full_join(tibble_frame_info, tibble_frame_info_temp, by = "translation_frame")
# finally join the tibblised parts of the list to the non-tibblised.
list_half_tibblised <- splice("frame_info" = tibble_frame_info, b1[-element.indices_frame_info])
fully_tibblised_list <- list_half_tibblised %>% flatten %>% as_tibble
return(fully_tibblised_list)
} ) # L2
save(list_3FT_result_unnest_temp_2, file = paste(tempdir, "list_3FT_result_unnest_temp_2_chr_", a4, "_part_", L2_index, ".Rlist", sep = ""), compress = FALSE)
return(NULL)
}, .progress = TRUE ) # L1a
return(NULL)
} ) # L1
shiny::runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
runApp('/mnt/LTS/projects/2020_isoform_nomenclature/nomenclature_app/app_native/EDN_suite')
