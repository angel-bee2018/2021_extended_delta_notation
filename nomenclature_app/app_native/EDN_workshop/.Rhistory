```
### DE using limma-trend
```{r}
pvalue_cutoff <- 0.05
fold_change_cutoff <- 1.5
# cryptic function to select columns and t-test each row
# return the p.value only
do_t.test_per_row_of_table <- function(table, column_regexpr_1, column_regexpr_2, no_more_than_x_na = 1) {
cat("column_regexpr_1: ", column_regexpr_1, "\ncolumn_regexpr_2: ", column_regexpr_2, "\n")
purrr::map2(
.x = table %>% dplyr::select(contains(column_regexpr_1)) %>% purrr::array_tree(margin = 1),
.y = table %>% dplyr::select(contains(column_regexpr_2)) %>% purrr::array_tree(margin = 1),
.f = function(a1, a2) {
if (which(is.na(a1)) %>% length > 1 | which(is.na(a2)) %>% length > 1) {
result <- NA
} else {
result <- t.test(a1 %>% na.omit, a2 %>% na.omit) %>% .$p.value}
return(result)
} ) %>% unlist %>% return
}
list_of_eigenMS_t.test_results <- list_of_eigenMS_results_quantitative_cleaned[c("con_sp.hsa.canonical.isoforms", "con_sp.hsa.canonical.isoforms_trembl")] %>%
purrr::map_depth(.depth = 2, .f = ~.x %>%
add_column(
"pvalue_30m_vs_ud_minus_ud_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "30m", column_regexpr_2 = "ud_vs_ud", no_more_than_x_na = 1),
"pvalue_1h_vs_ud_minus_ud_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1h", column_regexpr_2 = "ud_vs_ud", no_more_than_x_na = 1),
"pvalue_6h_vs_ud_minus_ud_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "6h", column_regexpr_2 = "ud_vs_ud", no_more_than_x_na = 1),
"pvalue_1d_vs_ud_minus_ud_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1d", column_regexpr_2 = "ud_vs_ud", no_more_than_x_na = 1),
"pvalue_1h_vs_ud_minus_30m_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1h", column_regexpr_2 = "30m", no_more_than_x_na = 1),
"pvalue_6h_vs_ud_minus_30m_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "6h", column_regexpr_2 = "30m", no_more_than_x_na = 1),
"pvalue_1d_vs_ud_minus_30m_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1d", column_regexpr_2 = "30m", no_more_than_x_na = 1),
"pvalue_6h_vs_ud_minus_1h_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "6h", column_regexpr_2 = "1h", no_more_than_x_na = 1),
"pvalue_1d_vs_ud_minus_1h_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1d", column_regexpr_2 = "1h", no_more_than_x_na = 1),
"pvalue_1d_vs_ud_minus_6h_vs_ud" = do_t.test_per_row_of_table(table = .x, column_regexpr_1 = "1d", column_regexpr_2 = "6h", no_more_than_x_na = 1),
"logFC_30m_vs_ud_minus_ud_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("30m")))^2)/rowMeans((.x %>% dplyr::select(contains("ud_vs_ud")))^2)),
"logFC_1h_vs_ud_minus_ud_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1h")))^2)/rowMeans((.x %>% dplyr::select(contains("ud_vs_ud")))^2)),
"logFC_6h_vs_ud_minus_ud_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("6h")))^2)/rowMeans((.x %>% dplyr::select(contains("ud_vs_ud")))^2)),
"logFC_1d_vs_ud_minus_ud_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1d")))^2)/rowMeans((.x %>% dplyr::select(contains("ud_vs_ud")))^2)),
"logFC_1h_vs_ud_minus_30m_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1h")))^2)/rowMeans((.x %>% dplyr::select(contains("30m")))^2)),
"logFC_6h_vs_ud_minus_30m_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("6h")))^2)/rowMeans((.x %>% dplyr::select(contains("30m")))^2)),
"logFC_1d_vs_ud_minus_30m_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1d")))^2)/rowMeans((.x %>% dplyr::select(contains("30m")))^2)),
"logFC_6h_vs_ud_minus_1h_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("6h")))^2)/rowMeans((.x %>% dplyr::select(contains("1h")))^2)),
"logFC_1d_vs_ud_minus_1h_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1d")))^2)/rowMeans((.x %>% dplyr::select(contains("1h")))^2)),
"logFC_1d_vs_ud_minus_6h_vs_ud" = log2(rowMeans((.x %>% dplyr::select(contains("1d")))^2)/rowMeans((.x %>% dplyr::select(contains("6h")))^2))
) )
list_of_eigenMS_t.test_results_significant <- purrr::map_depth(
.x = list_of_eigenMS_t.test_results,
.depth = 2,
.f = function(b1) {
# DEBUG ###
# b1 <- list_of_eigenMS_t.test_results$`con_sp.hsa.canonical.isoforms`$peptides
###########
vector_logical_significant_rowwise <- purrr::map2(.x = b1 %>% dplyr::select(contains("pvalue")) %>% array_tree(margin = 1), .y = b1 %>% dplyr::select(contains("logFC")) %>% array_tree(margin = 1), .f = ~any(.x %>% na.omit < pvalue_cutoff & .y %>% na.omit %>% abs > log2(fold_change_cutoff))) %>% unlist
return(b1[which(vector_logical_significant_rowwise == TRUE), ])
} )
mutual_consensus_cutoff <- 0.5
# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")
set.seed(7)
random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)
list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))
plan(list(tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 16)))
# options(mc.cores = 16)
# note: this loop returns just the scaled MQ ratios.
# it also plots the consensus metrix and export the edge tables for ClusterONE to crunch. :)
list_scaled_MQ_ratios <- future_map2(
.x = list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"],
.y = names(list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"]),
.f = function(.x, .y) {
# DEBUG ###
# .x <- list_of_significant_items_averaged[["sp.hsa.canonical.isoforms_junc.exons"]]
# .y <- names(list_of_significant_items_averaged["sp.hsa.canonical.isoforms_junc.exons"])
###########
a1 <- .x
a2 <- .y
cat("\nnow processing", a2, "at level 1")
purrr::map2(.x = a1, .y = names(a1), .f = function(.x, .y) {
# DEBUG ###
# .x <- a1[[1]]
# .y <- names(a1) %>% .[[1]]
###########
b1 <- .x
b2 <- .y
cat("\nnow processing", b2, "at level 2")
if(! dir.exists(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = "")) ) {
dir.create(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""), recursive = TRUE)}
setwd(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""))
tibble_scaled <- b1 %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble
# return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
# EXECUTE CONSENSUS SOM
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
# DEBUG ###
# .x <- list_seeds_and_dimensions_to_loop[[1]]
###########
cat("\nprocessing", .y)
set.seed(.x[[3]])
som(tibble_scaled %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
}, .progress = TRUE, .options = future_options(globals = c("tibble_scaled", "dplyr", "som")) ) %>% as.data.frame
# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- b1$id
# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>%
future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))
# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))
# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- b1$id
# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% Rfast::Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})
matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)
ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
xlab(b2) +
theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./dendrogram_som_consensus_matrix_", a2, "_", b2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)
# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")
# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)
ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
geom_tile(aes(x = id, y = variable)) +
ggtitle(paste("Consensus matrix for kinase substrate analysis\nOB phosphoproteome", a2, "\n", b2, sep = "")) +
scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)
# write.table(x = tibble_consensus_matrix_combinedexpr_long, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree
# debugging purposes only
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]
# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))
names(list_cooccurring_items) <- list_ids_for_looping
# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")
# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2
# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.
list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")
list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")
# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])
tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))
write.table(x = tibble_pairwise_edges_unfiltered, file = paste("./consensus_edge_table_anyintersection_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")
# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]
pdf(file = paste("./densityplot_PNC_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric),
main = paste("Density distribution of pairwise neighbours in common", a2, b2, sep = "\n"))
dev.off()
pdf(file = paste("./densityplot_jaccard_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric),
main = paste("Density distribution of jaccard similarity", a2, b2, sep = "\n"))
dev.off()
write.table(x = tibble_pairwise_edges_filtered, file = paste("./consensus_edge_table_intersection1_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
} ) %>% return
} )
plan(list(tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 16)))
plan(list(tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 16)))
# options(mc.cores = 16)
# note: this loop returns just the scaled MQ ratios.
# it also plots the consensus metrix and export the edge tables for ClusterONE to crunch. :)
list_scaled_MQ_ratios <- future_map2(
.x = list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"],
.y = names(list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"]),
.f = function(a1, a2) {
# DEBUG ###
# .x <- list_of_significant_items_averaged[["sp.hsa.canonical.isoforms_junc.exons"]]
# .y <- names(list_of_significant_items_averaged["sp.hsa.canonical.isoforms_junc.exons"])
###########
cat("\nnow processing", a2, "at level 1")
future_map2(.x = a1, .y = names(a1), .f = function(b1, b2) {
# DEBUG ###
# .x <- a1[[1]]
# .y <- names(a1) %>% .[[1]]
###########
cat("\nnow processing", b2, "at level 2")
if(! dir.exists(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = "")) ) {
dir.create(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""), recursive = TRUE)}
setwd(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""))
tibble_scaled <- b1 %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble
# return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
# EXECUTE CONSENSUS SOM
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
# DEBUG ###
# .x <- list_seeds_and_dimensions_to_loop[[1]]
###########
cat("\nprocessing", .y)
set.seed(.x[[3]])
som(tibble_scaled %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
}, .progress = TRUE, .options = future_options(globals = c("tibble_scaled", "dplyr", "som")) ) %>% as.data.frame
# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- b1$id
# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>%
future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))
# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))
# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- b1$id
# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% Rfast::Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})
matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)
ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
xlab(b2) +
theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./dendrogram_som_consensus_matrix_", a2, "_", b2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)
# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")
# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)
ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
geom_tile(aes(x = id, y = variable)) +
ggtitle(paste("Consensus matrix for kinase substrate analysis\nOB phosphoproteome", a2, "\n", b2, sep = "")) +
scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)
# write.table(x = tibble_consensus_matrix_combinedexpr_long, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree
# debugging purposes only
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]
# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))
names(list_cooccurring_items) <- list_ids_for_looping
# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")
# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2
# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.
list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")
list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")
# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])
tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))
write.table(x = tibble_pairwise_edges_unfiltered, file = paste("./consensus_edge_table_anyintersection_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")
# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]
pdf(file = paste("./densityplot_PNC_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric),
main = paste("Density distribution of pairwise neighbours in common", a2, b2, sep = "\n"))
dev.off()
pdf(file = paste("./densityplot_jaccard_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric),
main = paste("Density distribution of jaccard similarity", a2, b2, sep = "\n"))
dev.off()
write.table(x = tibble_pairwise_edges_filtered, file = paste("./consensus_edge_table_intersection1_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
} ) %>% return
}, .progress = TRUE)
list_of_significant_items_averaged <- purrr::map2(
.x = list_of_eigenMS_t.test_results_significant,
.y = names(list_of_eigenMS_t.test_results_significant),
.f = function(a1, a2) {
# DEBUG ###
# .x <- list_of_eigenMS_t.test_results_significant[[1]]
# .y <- names(list_of_eigenMS_t.test_results_significant) %>% .[[1]]
###########
cat("now processing", a2, "at level 1\n")
L2_list <- purrr::map2(.x = a1, .y = names(a1), .f = function(b1, b2) {
# DEBUG ###
# b1 <- list_of_eigenMS_t.test_results_significant$con_sp.hsa.canonical.isoforms$peptides
# b2 <-list_of_eigenMS_t.test_results_significant$con_sp.hsa.canonical.isoforms %>% .["peptides"] %>% names
###########
cat("now processing", b2, "at level 2\n")
raw_tibble <- b1 %>% .[, 1:16]
design_factor_info <- factor(x = gsub(x = colnames(raw_tibble %>% dplyr::select(-id)), pattern = "^([^\\|]+).*", replacement = "\\1", perl = TRUE), levels = c("30m_vs_ud", "1h_vs_ud", "6h_vs_ud", "1d_vs_ud", "ud_vs_ud"))
tibble_average_values <- average_replicates_by_column(table = raw_tibble %>% dplyr::select(-id), design_factor = design_factor_info, min_replicates = 1) %>%
add_column("id" = raw_tibble$id, .before = 1) %>%
# only keep complete time series for the clustering
na.omit
# %>%
#   # add the MSC column cause we took ratios
#   add_column("mean|ud_vs_ud" = 1, .after = 1)
return(tibble_average_values)
} ) %>% return
} )
plan(list(tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 4),
tweak(multiprocess, workers = 16)))
# options(mc.cores = 16)
# note: this loop returns just the scaled MQ ratios.
# it also plots the consensus metrix and export the edge tables for ClusterONE to crunch. :)
list_scaled_MQ_ratios <- future_map2(
.x = list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"],
.y = names(list_of_significant_items_averaged["con_sp.hsa.canonical.isoforms"]),
.f = function(a1, a2) {
# DEBUG ###
# .x <- list_of_significant_items_averaged[["sp.hsa.canonical.isoforms_junc.exons"]]
# .y <- names(list_of_significant_items_averaged["sp.hsa.canonical.isoforms_junc.exons"])
###########
cat("\nnow processing", a2, "at level 1")
future_map2(.x = a1, .y = names(a1), .f = function(b1, b2) {
# DEBUG ###
# .x <- a1[[1]]
# .y <- names(a1) %>% .[[1]]
###########
cat("\nnow processing", b2, "at level 2")
if(! dir.exists(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = "")) ) {
dir.create(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""), recursive = TRUE)}
setwd(paste(R_processing_results_dir, "kinase_substrate_analysis/", sep = ""))
tibble_scaled <- b1 %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble
# return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
# EXECUTE CONSENSUS SOM
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
# DEBUG ###
# .x <- list_seeds_and_dimensions_to_loop[[1]]
###########
cat("\nprocessing", .y)
set.seed(.x[[3]])
som(tibble_scaled %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
}, .progress = TRUE, .options = future_options(globals = c("tibble_scaled", "dplyr", "som")) ) %>% as.data.frame
# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- b1$id
# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>%
future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))
# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))
# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- b1$id
# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% Rfast::Dist(method = "euclidean") %>% as.dist
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})
matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)
ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
xlab(b2) +
theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./dendrogram_som_consensus_matrix_", a2, "_", b2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)
# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")
# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)
ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
geom_tile(aes(x = id, y = variable)) +
ggtitle(paste("Consensus matrix for kinase substrate analysis\nOB phosphoproteome", a2, "\n", b2, sep = "")) +
scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
ggsave(filename = paste("./heatmap_som_consensus_matrix_combinedexpr_", a2, "_", b2, ".tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)
# write.table(x = tibble_consensus_matrix_combinedexpr_long, file = paste(results_directory_figures, "heatmap_som_consensus_matrix_combinedexpr_", nrow(PSI_levels_timeseries_OB_wide), "_junctions_OBseries_any_", p_or_q_value, qpvalue_cutoff, "_dPSI_greaterthan_", dPSI_cutoff, "_sweep_from_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree
# debugging purposes only
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]
# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))
names(list_cooccurring_items) <- list_ids_for_looping
# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")
# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2
# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.
list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")
list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")
# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])
tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))
write.table(x = tibble_pairwise_edges_unfiltered, file = paste("./consensus_edge_table_anyintersection_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")
# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]
pdf(file = paste("./densityplot_PNC_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric),
main = paste("Density distribution of pairwise neighbours in common", a2, b2, sep = "\n"))
dev.off()
pdf(file = paste("./densityplot_jaccard_distribution_", a2, "_", b2, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric),
main = paste("Density distribution of jaccard similarity", a2, b2, sep = "\n"))
dev.off()
write.table(x = tibble_pairwise_edges_filtered, file = paste("./consensus_edge_table_intersection1_consensus0.5_", a2, "_", b2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
return(cbind(b1[, "id"], tibble_scaled) %>% as_tibble)
} ) %>% return
}, .progress = TRUE)
shiny::runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp()
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp()
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
?reactive
?paste0
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
?outputOptions
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp()
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
?server
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
runApp('/mnt/Tertiary/sharedfolder/isoform_nomenclature_project/rshiny_nomenclature_app/app/extended_delta_generator')
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
tibble_ref_gtf <- rtracklayer::import(con = "data/latest_ensembl_GTF.gtf", format = "gtf") %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
